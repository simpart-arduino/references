/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* require */\n__webpack_require__(/*! mofron */ \"./node_modules/mofron/index-exposed.js\");\n\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst Button = __webpack_require__(/*! mofron-comp-button */ \"./node_modules/mofron-comp-button/index.js\");\n\nconst Dialog = __webpack_require__(/*! mofron-comp-dialog */ \"./node_modules/mofron-comp-dialog/index.js\");\n\nconst Input = __webpack_require__(/*! mofron-comp-input */ \"./node_modules/mofron-comp-input/index.js\");\n\nconst VrtPos = __webpack_require__(/*! mofron-effect-vrtpos */ \"./node_modules/mofron-effect-vrtpos/index.js\");\n\nconst SynWH = __webpack_require__(/*! mofron-effect-synwhei */ \"./node_modules/mofron-effect-synwhei/index.js\");\n\nconst HrzCenter = __webpack_require__(/*! mofron-layout-hrzcenter */ \"./node_modules/mofron-layout-hrzcenter/index.js\");\n\nconst loMargin = __webpack_require__(/*! mofron-layout-margin */ \"./node_modules/mofron-layout-margin/index.js\");\n\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\n\ntry {\n  /* access */\n  if (true === mofron.util.common.chkacc({\n    device: 'mobile'\n  })) {\n    if (true === mofron.window.isPortrait()) {\n      document.documentElement.setAttribute('style', 'font-size:1200%;');\n    }\n\n    mofron.window.portraitEvent(() => {\n      document.documentElement.setAttribute('style', 'font-size:1200%;');\n    });\n  }\n\n  if (true === mofron.util.common.chkacc({\n    device: 'mobile'\n  })) {\n    if (true === mofron.window.isLandscape()) {\n      document.documentElement.setAttribute('style', 'font-size:800%;');\n    }\n\n    mofron.window.landscapeEvent(() => {\n      document.documentElement.setAttribute('style', 'font-size:800%;');\n    });\n  }\n\n  if (true === mofron.util.common.chkacc({\n    device: 'tablet'\n  })) {\n    document.documentElement.setAttribute('style', 'font-size:800%;');\n  }\n  /* script (extern) */\n\n  /* script (init) */\n\n\n  let SSID_UUID = \"8ae02df6-13a1-a643-afc6-e38015acdc17\";\n  let PASS_UUID = \"59eb653a-f480-031b-44c8-757de2a66a96\";\n  let CONN_UUID = \"56c050ba-d16d-8330-12c8-a723b1117c6f\";\n  let g_chara = {};\n  let g_bledev = null;\n\n  let search = () => {\n    navigator.bluetooth.requestDevice({\n      acceptAllDevices: false,\n      filters: [{\n        namePrefix: 'Soil-Gateway'\n      }],\n      optionalServices: ['64ac6782-77ab-bb50-2549-321900cc35b7']\n    }).then(device => {\n      g_bledev = device;\n      return device.gatt.connect();\n    }).then(server => {\n      return server.getPrimaryService('64ac6782-77ab-bb50-2549-321900cc35b7');\n    }).then(service => {\n      return service.getCharacteristics();\n    }).then(characteristics => {\n      for (idx in characteristics) {\n        g_chara[characteristics[idx].uuid] = characteristics[idx]; //        if (CONN_UUID == characteristics[idx].uuid) {\n        //            characteristics[idx].addEventListener('characteristicvaluechanged', conn_event);\n        //            characteristics[idx].startNotifications();\n        //        }\n      } //alert(g_bledev.gatt.connected);\n\n\n      wificnf.visible(true);\n    });\n  };\n\n  let connect = () => {\n    try {\n      let encoder = new TextEncoder('utf-8');\n      g_chara[SSID_UUID].writeValue(encoder.encode(wcnf_acc.value())).then(() => {\n        return g_chara[PASS_UUID].writeValue(encoder.encode(wcnf_pwd.value()));\n      }).then(() => {\n        return g_chara[CONN_UUID].writeValue(encoder.encode('true'));\n      }).then(() => {\n        g_bledev.gatt.disconnect(); //alert(\"finished send data\");\n      });\n    } catch (e) {\n      alert(e.stack);\n    }\n  };\n  /* template */\n\n  /* component */\n\n\n  let cmp0_0 = new Button();\n  let cmp0 = new mofron.class.Component();\n  let wcnf_acc = new Input();\n  let wcnf_pwd = new Input();\n  let wificnf_0 = new mofron.class.Component();\n  let wificnf = new Dialog();\n  let root_cmp = new mofron.class.Component();\n  cmp0.child([cmp0_0]);\n  wificnf_0.child([wcnf_acc, wcnf_pwd]);\n  wificnf.child([wificnf_0]);\n  root_cmp.child([cmp0, wificnf]);\n  cmp0_0.config({\n    size: new mofron.class.ConfArg(\"100%\", \"0.5rem\"),\n    clickEvent: search,\n    effect: new VrtPos(\"center\"),\n    text: \"Search BLE Device_1\"\n  });\n  cmp0.config({\n    effect: new SynWH(),\n    layout: new HrzCenter(80)\n  });\n  wcnf_acc.config({\n    name: \"wcnf_acc\",\n    size: new mofron.class.ConfArg(\"100%\", \"0.5rem\"),\n    label: \"Access Point\",\n    type: \"url\"\n  });\n  wcnf_pwd.config({\n    name: \"wcnf_pwd\",\n    size: new mofron.class.ConfArg(\"100%\", \"0.5rem\"),\n    label: \"Password\",\n    type: \"password\"\n  });\n  wificnf_0.config({\n    layout: new loMargin(\"top\", \"0.2rem\")\n  });\n  wificnf.config({\n    name: \"wificnf\",\n    layout: new HrzCenter(80),\n    buttonEvent: connect,\n    title: \"WiFi Config\",\n    button: \"Connect\"\n  });\n  /* script (before) */\n\n  /* start visible */\n\n  root_cmp.visible(true, () => {\n    try {\n      /* script (after) */\n    } catch (e) {\n      console.error(e.stack);\n    }\n  });\n} catch (e) {\n  console.error(e.stack);\n}\n\n//# sourceURL=webpack:///./js/index.js?");

/***/ }),

/***/ "./node_modules/mofron/index-exposed.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/index-exposed.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ \"./node_modules/mofron/index.js\");\n\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../expose-loader/dist/runtime/getGlobalThis.js */ \"./node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\n\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nvar ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___ = ___EXPOSE_LOADER_IMPORT___.mofron;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"_mofron\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"_mofron\"] = ___EXPOSE_LOADER_IMPORT_MODULE_LOCAL_NAME___;else throw new Error('[exposes-loader] The \"_mofron\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option');\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n//# sourceURL=webpack:///./node_modules/mofron/index-exposed.js?");

/***/ }),

/***/ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js":
/*!******************************************************************!*\
  !*** ./node_modules/expose-loader/dist/runtime/getGlobalThis.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(" // eslint-disable-next-line func-names\n\nmodule.exports = function () {\n  if (typeof globalThis === \"object\") {\n    return globalThis;\n  }\n\n  var g;\n\n  try {\n    // This works if eval is allowed (see CSP)\n    // eslint-disable-next-line no-new-func\n    g = this || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") {\n      return window;\n    } // This works if the self reference is available\n\n\n    if (typeof self === \"object\") {\n      return self;\n    } // This works if the global reference is available\n\n\n    if (typeof __webpack_require__.g !== \"undefined\") {\n      return __webpack_require__.g;\n    }\n  }\n\n  return g;\n}();\n\n//# sourceURL=webpack:///./node_modules/expose-loader/dist/runtime/getGlobalThis.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-button/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-button/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  mofron-comp-button/index.js\n * @brief button component for mofron\n * @license MIT\n */\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst Click = __webpack_require__(/*! mofron-event-click */ \"./node_modules/mofron-event-click/index.js\");\n\nconst SynHei = __webpack_require__(/*! mofron-effect-synchei */ \"./node_modules/mofron-effect-synchei/index.js\");\n\nconst Border = __webpack_require__(/*! mofron-effect-border */ \"./node_modules/mofron-effect-border/index.js\");\n\nconst cmputl = mofron.util.component;\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * constructor\n   * \n   * @param (mixed) string: text parameter\n   *                object: component config\n   * @param (mixed) clickEvent parameter\n   * @short text,clickEvent\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Button');\n      this.shortForm('text', 'clickEvent');\n      this.confmng().add(\"clickEvent\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"text\", {\n        type: \"Text\"\n      });\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts('button');\n      /* set button text */\n\n      this.child(this.text());\n      /*** set default config ***/\n\n      let pvt = {\n        private: true\n      };\n      this.height('0.25rem', pvt);\n      this.status(true);\n      this.text().effect(new SynHei(this));\n      /* border */\n\n      this.style({\n        'border': 'solid 0.01rem #787878'\n      }, pvt);\n      this.event(new Click({\n        tag: \"Button\"\n      }), pvt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button text contents\n   * \n   * @param (mixed) string: button text contents\n   *                mofron-comp-text: button text component\n   * @param (mixed) text component config\n   * @return (mofron-comp-text) button text\n   * @type parameter\n   */\n\n\n  text(txt, cnf) {\n    try {\n      if ('string' === typeof txt) {\n        this.text().text(txt);\n        this.confmng(\"text\", this.text());\n        return;\n      }\n\n      if (undefined !== cnf) {\n        this.text().config(cnf);\n      }\n\n      if (true === comutl.isinc(txt, \"Text\")) {\n        this.confmng(\"text\", txt);\n      }\n\n      return this.innerComp('text', txt, Text);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button click event\n   *\n   * @param (function) click event function\n   * @param (mixed) function parameter\n   * @type parameter\n   */\n\n\n  clickEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        /* getter */\n        return this.confmng(\"clickEvent\");\n      }\n      /* setter */\n\n\n      if (true === Array.isArray(fnc)) {\n        for (let fidx in fnc) {\n          this.clickEvent(fnc[fidx][0], fnc[fidx][1]);\n        }\n\n        return;\n      }\n\n      this.confmng(\"clickEvent\", [fnc, prm]);\n      let clk = this.event({\n        modname: \"Click\",\n        tag: \"Button\"\n      });\n      clk.listener(fnc, prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button text color\n   * \n   * @param (mixed (color)) string: button text color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (mixed) button text color\n   *                 null: not set yet\n   * @type parameter\n   */\n\n\n  mainColor(clr, opt) {\n    try {\n      return this.text().mainColor(clr, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button border color\n   * \n   * @param (mixed (color)) string: button border color, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (mixed) button border color\n   *                 null; not set yet\n   * @type parameter\n   */\n\n\n  accentColor(clr, opt) {\n    try {\n      if (undefined !== clr) {\n        this.style({\n          'border-style': null === clr ? 'none' : 'solid'\n        }, opt);\n      }\n\n      return cmputl.color(this, 'border-color', clr, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * change disable mode\n   * change this button to grayout and it will be can not click.\n   *\n   * @type function\n   */\n\n\n  disabled() {\n    try {\n      this.status(false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * change enable mode\n   *\n   * @type function\n   */\n\n\n  enabled() {\n    try {\n      this.status(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button status\n   *\n   * @param (boolean) change enable/disable mode\n   * @return (boolean) current status\n   * @type parameter\n   */\n\n\n  status(sts) {\n    try {\n      if (undefined === sts) {\n        /* getter */\n        return 'disabled' === this.childDom().attrs('disabled') ? false : true;\n      }\n      /* setter */\n\n\n      if ('boolean' !== typeof sts) {\n        throw new Error('invalid parameter');\n      }\n\n      this.childDom().attrs({\n        'disabled': true === sts ? null : 'disabled'\n      });\n      this.childDom().style({\n        'cursor': true === sts ? 'pointer' : 'not-allowed'\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-button/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-dialog/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-dialog/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-comp-dialog/index.js\n * @brief dialog component for mofron\n *        modal dialog, but hide when clicking outside the dialog\n * @author simpart\n */\nconst Modal = __webpack_require__(/*! mofron-comp-modalfil */ \"./node_modules/mofron-comp-modalfil/index.js\");\n\nconst Frame = __webpack_require__(/*! mofron-comp-ttlframe */ \"./node_modules/mofron-comp-ttlframe/index.js\");\n\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst Button = __webpack_require__(/*! mofron-comp-button */ \"./node_modules/mofron-comp-button/index.js\");\n\nconst Click = __webpack_require__(/*! mofron-event-click */ \"./node_modules/mofron-event-click/index.js\");\n\nconst ClkFcs = __webpack_require__(/*! mofron-event-clkfocus */ \"./node_modules/mofron-event-clkfocus/index.js\");\n\nconst vsClick = __webpack_require__(/*! mofron-event-visiclick */ \"./node_modules/mofron-event-visiclick/index.js\");\n\nconst HrzPos = __webpack_require__(/*! mofron-effect-hrzpos */ \"./node_modules/mofron-effect-hrzpos/index.js\");\n\nconst VrtPos = __webpack_require__(/*! mofron-effect-vrtpos */ \"./node_modules/mofron-effect-vrtpos/index.js\");\n\nconst SyncHei = __webpack_require__(/*! mofron-effect-synchei */ \"./node_modules/mofron-effect-synchei/index.js\");\n\nconst SyncWid = __webpack_require__(/*! mofron-effect-syncwid */ \"./node_modules/mofron-effect-syncwid/index.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * initialize component\n   * \n   * @param (mixed) title parameter\n   *                object: component option\n   * @short title\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('Dialog');\n      this.shortForm('title');\n      this.confmng().add(\"buttonEvent\", {\n        type: \"event\",\n        list: true\n      });\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      /* init inner comp */\n      this.frame(new Frame());\n      this.btnWrap(new mofron.class.Component());\n      this.modalfil(new Modal());\n      super.initDomConts();\n      /* set close button */\n\n      this.closeComp(new Text({\n        style: new mofron.class.ConfArg({\n          \"font-family\": \"auto\"\n        }, {\n          locked: true\n        }),\n        text: '&times;',\n        mainColor: [120, 120, 120]\n      }));\n      this.frame().header().child(this.closeComp());\n      /* set frame contents */\n\n      this.modalfil().child(this.frame());\n      let conts = new mofron.class.Component({\n        effect: new SyncWid(this.frame())\n      });\n      this.frame().child([conts, this.btnWrap()]);\n      /* set modal */\n\n      this.child([this.modalfil()]);\n      /* update target dom */\n\n      this.childDom(conts.childDom());\n      this.styleDom(this.frame().childDom());\n      /* default size */\n\n      this.size('4rem', '3rem');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set button event\n   * \n   * @type private\n   */\n\n\n  beforeRender() {\n    try {\n      super.beforeRender();\n      /* set button event */\n\n      let btn = this.button();\n      let bevt = this.buttonEvent();\n\n      if (0 < bevt.length && 0 < btn.length) {\n        for (let bidx in btn) {\n          for (let eidx in bevt) {\n            btn[bidx].clickEvent(bevt[eidx][0], bevt[eidx][1]);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dialog title\n   * \n   * @param (mixed) string: title text\n   *                mofron-comp-text: title text component\n   * @param (dict) text config\n   * @return (mofron-comp-text) title text component\n   * @type parameter\n   */\n\n\n  title(prm, cnf) {\n    try {\n      let ret = this.frame().text(prm);\n\n      if (undefined !== prm && null === this.frame().text().style(\"margin-left\")) {\n        this.frame().text().style({\n          \"margin-left\": \"0.2rem\"\n        });\n        this.frame().text().config(cnf);\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button wrapper\n   * \n   * @param (component) replace button wrapper\n   * @return (component) buttom wrapper component\n   * @type private\n   */\n\n\n  btnWrap(prm) {\n    try {\n      if (true === comutl.iscmp(prm)) {\n        prm.config({\n          style: {\n            \"position\": \"absolute\",\n            \"display\": \"none\"\n          },\n          effect: [new VrtPos('bottom', '0.3rem'), new HrzPos('center')]\n        });\n      }\n\n      return this.innerComp('btnWrap', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * buttom component\n   * \n   * @param (mixed) string: button text\n   *                mofron-comp-button: dialog button component\n   * @param (dict) button config \n   * @return (mofron-comp-button) dialog button component\n   * @type parameter\n   */\n\n\n  button(prm, opt) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return this.btnWrap().child();\n      }\n      /* setter */\n\n\n      this.btnWrap().style({\n        \"display\": \"flex\"\n      });\n\n      if (true === Array.isArray(prm)) {\n        for (let bidx in prm) {\n          this.button(prm[bidx], opt);\n        }\n\n        return;\n      }\n\n      if ('string' === typeof prm) {\n        prm = new Button({\n          text: prm,\n          width: \"1rem\"\n        });\n      }\n\n      if (0 !== this.button().length) {\n        prm.style({\n          'margin-left': '0.2rem'\n        });\n      }\n\n      if (undefined !== opt) {\n        prm.config(opt);\n      }\n\n      this.btnWrap().child(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * button event\n   *\n   * @param (function) button event\n   * @param (mixed) event parameter\n   * @return (array) [[event,param], ...]\n   * @type parameter\n   */\n\n\n  buttonEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        /* getter */\n        return this.confmng(\"buttonEvent\");\n      }\n      /* setter */\n\n\n      this.confmng(\"buttonEvent\", [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * close component in header\n   * \n   * @param (component) dialog close component\n   * @reutrn (component) dialog close component\n   * @type parameter\n   */\n\n\n  closeComp(prm) {\n    try {\n      if (true === comutl.iscmp(prm)) {\n        let vsclk = new vsClick('disable', this);\n        prm.config({\n          event: new vsClick('disable', this),\n          effect: [new SyncHei(this.frame().header()), new HrzPos('right', '0.1rem')]\n        });\n      }\n\n      return this.innerComp('closeComp', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dialog frame\n   * \n   * @param (mofron-comp-frame) dialog frame component\n   * @return (mofron-comp-frame) dialog frame component\n   * @type parameter\n   */\n\n\n  frame(prm) {\n    try {\n      let ret = this.innerComp('frame', prm);\n\n      if (undefined !== prm) {\n        let fcs = (fcs1, fcs2, fcs3) => {\n          try {\n            if (false === fcs2) {\n              fcs3.visible(false);\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        prm.config({\n          style: {\n            \"position\": \"relative\",\n            \"display\": \"none\"\n          },\n          header: new mofron.class.PullConf({\n            height: '0.4rem'\n          }),\n          mainColor: [230, 230, 230],\n          baseColor: 'white',\n          event: new ClkFcs({\n            listener: new mofron.class.ConfArg(fcs, this),\n            pointer: false,\n            tag: \"Dialog\",\n            suspend: true\n          }),\n          effect: [new HrzPos('center'), new VrtPos('center')]\n        });\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * modalfilter component\n   * \n   * @param (mofron-comp-modalfil) modal filter component\n   * @return (mofron-comp-modalfil) modal filter component\n   * @type private\n   */\n\n\n  modalfil(prm) {\n    try {\n      return this.innerComp('modalfil', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * frame header base color\n   * \n   * @param (mixed) string: color name, #hex\n   *                array: [red, green, blue, (alpha)]\n   * @param (option) style option\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      return this.frame().header().baseColor(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * modal base color\n   * \n   * @param (mixed) string: color name, #hex\n   *                array: [red, green, blue, (alpha)]\n   * @param (option) style option\n   * @type parameter\n   */\n\n\n  accentColor(prm, opt) {\n    try {\n      return this.modalfil().baseColor(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set effect to frame component\n   * @type private\n   */\n\n\n  effect(prm) {\n    try {\n      return this.frame().effect(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dialog height\n   * \n   * @param (string (size)) dialog height\n   *                        undefined: call as getter\n   * @param (dict) set size option\n   * @return (string (size)) dialog height\n   * @type parameter\n   */\n\n\n  height(prm, opt) {\n    try {\n      return this.frame().height(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dialog header height\n   * \n   * @param (string(size)) header height\n   *                       undefined: call as getter\n   * @param (dict) set size option\n   * @return (string(size)) dialog header height\n   * @type parameter\n   */\n\n\n  headerHeight(prm, opt) {\n    try {\n      return this.frame().header().height(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dialog width\n   * \n   * @param (string (size)) dialog width\n   *                        undefined: call as getter\n   * @return (string (size)) dialog height\n   * @type parameter\n   */\n\n\n  width(prm, opt) {\n    try {\n      return this.frame().width(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * modal filter, dialog frame visible\n   * \n   * @type private\n   */\n\n\n  visible(flg, cb) {\n    try {\n      if (undefined === flg) {\n        /* getter */\n        return this.modalfil().visible();\n      }\n      /* setter */\n\n\n      let dlg = this;\n      let fcs = this.frame().event({\n        name: \"ClkFocus\",\n        tag: \"Dialog\"\n      });\n\n      if (true === flg) {\n        this.modalfil().visible(flg, () => {\n          dlg.frame().visible(flg, cb);\n          fcs.status(flg);\n        });\n      } else {\n        this.frame().visible(flg, () => {\n          dlg.modalfil().visible(flg, cb);\n          fcs.status(flg);\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-dialog/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-formitem/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-formitem/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   mofron-comp-formitem/index.js\n * @brief  base component for form item.\n *         this component has some function for form item.\n *         extending this class makes it easier to develop form item components.\n * @attention it needs to overwrite at extending class since some functions is an interface.\n * @license MIT\n */\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst onCommon = __webpack_require__(/*! mofron-event-oncommon */ \"./node_modules/mofron-event-oncommon/index.js\");\n\nconst comutl = mofron.util.common;\nconst ConfArg = mofron.class.ConfArg;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * initialize component\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short label\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname('FormItem');\n      this.shortForm('label');\n      /* init config */\n\n      this.confmng().add('required', {\n        type: 'boolean',\n        init: false\n      });\n      this.confmng().add('horizon', {\n        type: 'boolean',\n        init: false\n      });\n      this.confmng().add(\"focusEvent\", {\n        type: 'event',\n        list: true\n      });\n      this.confmng().add('changeEvent', {\n        type: 'event',\n        list: true\n      });\n      this.confmng().add('sendKey', {\n        type: 'string'\n      });\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      /* label */\n\n      this.child(this.label());\n      /* set focus event */\n\n      let itm = this;\n      this.event([new onCommon(() => {\n        let evt = itm.focusEvent();\n\n        for (let eidx in evt) {\n          evt[eidx][0](itm, true, evt[eidx][1]);\n        }\n      }, \"onfocus\"), new onCommon(() => {\n        let evt = itm.focusEvent();\n\n        for (let eidx in evt) {\n          evt[eidx][0](itm, false, evt[eidx][1]);\n        }\n      }, \"onblur\")], {\n        private: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set focus status\n   *\n   * @type private\n   */\n\n\n  afterRender() {\n    try {\n      super.afterRender();\n      this.focus(this.focus());\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * form item label setter/getter\n   *\n   * @param (mixed) string: label text\n   *                mofron-comp-text: text component for label\n   *                undefined: call as getter\n   * @return (mofron-comp-text) text component for label\n   * @type parameter\n   */\n\n\n  label(prm) {\n    try {\n      if (true === comutl.isinc(prm, 'Text')) {\n        prm.config({\n          visible: false,\n          style: {\n            'margin-right': '0.05rem'\n          }\n        });\n      } else if ('string' === typeof prm) {\n        this.label().config({\n          text: prm,\n          style: {\n            'display': null\n          }\n        });\n        return;\n      }\n\n      return this.innerComp('label', prm, Text);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * horizontal config setter/getter\n   * \n   * @param (boolean) true: horizontal placing (form item is placed next to a label)\n   *                  false: normal placing (form item is placed under a label)\n   *                  undefined: call as getter\n   * @return (boolean) placing config\n   * @type parameter\n   */\n\n\n  horizon(prm) {\n    try {\n      if (undefined === prm) {\n        return 'flex' === this.rootDom()[0].style('display') ? true : false;\n      }\n      /* setter */\n\n\n      this.rootDom()[0].style({\n        'display': true === prm ? 'flex' : null\n      }, true);\n      this.confmng(\"horizon\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * config for required flag setter/getter\n   * it become required item in form if this flag is true\n   * \n   * @param (boolean) true: required item (An error is detected if data is sent when empty this item data)\n   *                  false: not required item\n   *                  undefined: call as getter\n   * @return (boolean) required flag\n   * @type parameter\n   */\n\n\n  required(flg) {\n    try {\n      return this.confmng('required', flg);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * item value\n   * interface for getter/setter of formitem\n   * \n   * @param (mixed) item value\n   * @return (mixed) item value\n   * @type private\n   */\n\n\n  value(prm) {\n    console.warn('not implements');\n  }\n  /**\n   * check item value about valid or invalid\n   * \n   * @return (mixed) string: error reason\n   *                 null: no error\n   * @type private\n   */\n\n\n  checkValue() {\n    try {\n      if (true === this.required()) {\n        if (null === this.value()) {\n          return '' === this.label().text() ? 'empty value' : this.label().text() + ' is required';\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * focus status setter/getter\n   * \n   * @param (boolean) true: focus this item\n   *                  false: defocus this item\n   *                  undefined: call as getter\n   * @return (boolean) focus status\n   * @type parameter\n   */\n\n\n  focus(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return document.activeElement === this.childDom().id() ? true : false;\n      }\n      /* setter */\n\n\n      if (true === this.isExists()) {\n        if (true === prm) {\n          this.childDom().getRawDom().focus();\n        } else {\n          this.childDom().getRawDom().blur();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * focus event function setter/getter\n   * \n   * @param (function) event function\n   *                   undefined: call as getter\n   * @param (mixed) function parameter\n   * @return (array) event list\n   * @type parameter\n   */\n\n\n  focusEvent(fnc, prm) {\n    try {\n      if (true === Array.isArray(fnc)) {\n        for (let fidx in fnc) {\n          this.focusEvent(fnc[fidx][0], fnc[fidx][1]);\n        }\n\n        return;\n      }\n\n      return this.confmng(\"focusEvent\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * change event function setter/getter\n   *\n   * @param (function) change event\n   *                   undefined: call as getter\n   * @param (mix) event parameter\n   * @return (array) event list\n   * @type private\n   */\n\n\n  changeEvent(fnc, prm) {\n    try {\n      if (true === Array.isArray(fnc)) {\n        for (let fidx in fnc) {\n          this.changeEvent(fnc[fidx][0], fnc[fidx][1]);\n        }\n\n        return;\n      }\n\n      return this.confmng('changeEvent', undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * item status setter/getter\n   * \n   * @param (boolean) true: change enable mode [default]\n   *                  false: change disable mode\n   *                  undefined: call as getter\n   * @return (boolean) current item status\n   * @type parameter\n   */\n\n\n  status(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return 'disabled' === this.childDom().attrs('disabled') ? true : false;\n      }\n      /* setter */\n\n\n      this.childDom().attrs({\n        'disabled': true === prm ? 'disabled' : null\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * enable form item\n   * \n   * @type function\n   */\n\n\n  enabled() {\n    try {\n      return this.status(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * disable form item\n   *\n   * @type function\n   */\n\n\n  disabled() {\n    try {\n      return this.status(false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * a key of POST data setter/getter\n   * \n   * @param (string) send key\n   *                 undefined: call as getter\n   * @return (string) send key\n   * @type parameter\n   */\n\n\n  sendKey(prm) {\n    try {\n      return this.confmng('sendKey', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * clear item value\n   *\n   * @type private\n   */\n\n\n  clear() {\n    console.warn('not implements');\n  }\n  /**\n   * item height setter/getter\n   * \n   * @param (string (size)) item height (if horizon function is false and visible function is true, height will be bisected.)\n   *                        undefined: call as getter\n   * @param (key-value) style option\n   * @return (mixed) string(size): item height\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  height(prm, opt) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        if (false === this.horizon() && (true === this.label().visible() || false === this.childDom().isPushed() && \"none\" !== this.label().style(\"display\"))) {\n          return comutl.sizesum(this.label().height(), super.height());\n        }\n\n        return super.height();\n      }\n      /* setter */\n\n\n      let set_siz = comutl.getsize(prm);\n\n      if (null == set_siz) {\n        return;\n      }\n\n      if (false === this.horizon() && true === this.label().visible()) {\n        super.height(comutl.roundup(set_siz.value() / 2) + set_siz.type(), opt);\n      } else {\n        super.height(set_siz, opt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-formitem/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-frame/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-frame/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   mofron-comp-frame/index.js\n * @brief  frame component for mofron\n * @feature default size is 1rem × 1rem\n *          frame size is includes border size\n * @license MIT\n */\nconst Radius = __webpack_require__(/*! mofron-effect-radius */ \"./node_modules/mofron-effect-radius/index.js\");\n\nconst Shadow = __webpack_require__(/*! mofron-effect-shadow */ \"./node_modules/mofron-effect-shadow/index.js\");\n\nconst Border = __webpack_require__(/*! mofron-effect-border */ \"./node_modules/mofron-effect-border/index.js\");\n\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * initialize frame component\n   * \n   * @param (mixed) width parameter\n   *                key-value: component option\n   * @param (string (size)) height parameter\n   * @short width,height\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname(\"Frame\");\n      this.shortForm(\"width\", \"height\");\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      let pvt = {\n        private: true\n      };\n      /* configure border style */\n\n      this.effect([new Border({\n        color: [190, 190, 190],\n        tag: \"Frame\"\n      }), new Radius(\"0rem\"), new Shadow(\"0rem\")], pvt);\n      this.childDom().style().listener(\"border-width\", (p1, p2, p3) => {\n        try {\n          let o_bdr = comutl.sizesum(p2[\"border-width\"], p2[\"border-width\"]);\n          p3.size(comutl.sizesum(cmputl.size(p3, \"width\"), o_bdr), comutl.sizesum(cmputl.size(p3, \"height\"), o_bdr));\n        } catch (e) {}\n      }, this);\n      this.width(\"1rem\", pvt);\n      this.height(\"1rem\", pvt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * background color\n   * \n   * @param (mixed (color)) string: background color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (string) background color\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      return cmputl.color(this, \"background\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border color\n   * \n   * @param (mixed (color)) string: border color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @return (mixed (color)) border color\n   * @type parameter\n   */\n\n\n  accentColor(prm, opt) {\n    try {\n      this.effect({\n        modname: \"Shadow\"\n      }).color(prm);\n      return this.effect({\n        modname: \"Border\"\n      }).color(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * radius effect\n   *\n   * @param (string (size)) radius effect value\n   * @return (string (size)) radius effect value\n   * @type parameter\n   */\n\n\n  radius(prm) {\n    try {\n      return this.effect({\n        modname: \"Radius\"\n      }).value(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * shadow effect\n   *\n   * @param (string (size)) shadow value\n   * @return (string (size)) shadow value\n   * @type parameter\n   */\n\n\n  shadow(prm) {\n    try {\n      return this.effect({\n        modname: \"Shadow\"\n      }).value(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border width setter\n   * \n   * @param (string(size)) top border width\n   * @param (string(size)) right border width\n   * @param (string(size)) bottom border width\n   * @param (string(size)) left border width\n   * @type parameter\n   */\n\n\n  borderWidth(top, right, bottom, left) {\n    try {\n      this.style({\n        \"border-width\": null\n      }, {\n        lock: true\n      });\n      this.style({\n        \"border-top-width\": top,\n        \"border-right-width\": right,\n        \"border-bottom-width\": bottom,\n        \"border-left-width\": left\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * frame width\n   * \n   * @param (string (size)) frame width\n   * @param (key-value) style option\n   * @return (string (size)) frame width\n   * @type parameter\n   */\n\n\n  width(prm, opt) {\n    try {\n      return this.frmsiz(\"width\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * frame height\n   * \n   * @param (string (size)) frame height\n   * @param (key-value) style option\n   * @return (string (size)) frame height\n   * @type parameter\n   */\n\n\n  height(prm, opt) {\n    try {\n      return this.frmsiz(\"height\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set frame size\n   * \n   * @param (string) size target (width,height)\n   * @type private\n   */\n\n\n  frmsiz(tgt, val, opt) {\n    try {\n      if (\"width\" !== tgt && \"height\" !== tgt) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let bdr_siz = this.effect({\n        name: \"Border\",\n        tag: \"Frame\"\n      }).width();\n      bdr_siz = comutl.sizesum(bdr_siz, bdr_siz);\n\n      if (undefined === val) {\n        /* getter */\n        return comutl.sizesum(super[tgt](), bdr_siz);\n      }\n      /* setter */\n\n\n      super[tgt](comutl.sizesum(val, null === bdr_siz ? null : \"-\" + bdr_siz));\n    } catch (e) {\n      return super[tgt](val);\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-frame/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-header/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-header/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   mofron-comp-header/index.js\n * @brief  header component for mofron\n *         This component for placing at the top of the page etc. and displaying the site title etc.\n * @feature A header's child components are placed horizontally since header has a horizon layout.\n * @attention it maybe needs a 'false' config at bind parameter that used as a child component.\n * @license MIT\n */\nconst Horizon = __webpack_require__(/*! mofron-layout-horizon */ \"./node_modules/mofron-layout-horizon/index.js\");\n\nconst cmputl = mofron.util.component;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * constructor\n   * \n   * @param (mixed) child parameter\n   *                key-value: component config\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      /* init config */\n\n      this.modname(\"Header\");\n      this.confmng().add(\"wrap\", {\n        type: \"Dom\"\n      });\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      let wrap = new mofron.class.Component();\n      this.child(wrap);\n      this.childDom(wrap.childDom());\n      let pvt = {\n        private: true\n      };\n      this.layout(new Horizon(), pvt);\n      this.style({\n        \"border-bottom-style\": \"solid\",\n        \"border-bottom-width\": \"0.01rem\"\n      }, pvt);\n      this.width(\"100%\", pvt);\n      this.height(\"0.5rem\", pvt);\n      this.bind(true);\n      this.mainColor([211, 211, 211], pvt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * header height\n   * \n   * @param (string (size)) header height (default is \"0.5rem\")\n   * @param (option) style option\n   * @return (string (size)) header height\n   * @type parameter\n   */\n\n\n  height(val, opt) {\n    try {\n      if (undefined === val) {\n        return this.rootDom()[0].style(\"height\");\n      }\n\n      this.rootDom()[0].style({\n        height: val\n      }, opt);\n      this.getTree().getChild()[0].height(val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * binding header \n   * \n   * @param (boolean) true: header position is fixed. display header even if user scrolls. (default)\n   *                  false: header position is not fixed.\n   * @return (boolean) binding config\n   * @type parameter\n   */\n\n\n  bind(flg) {\n    try {\n      if (undefined === flg) {\n        /* getter */\n        return 'fixed' === this.style('position') ? true : false;\n      }\n      /* setter */\n\n\n      if ('boolean' !== typeof flg) {\n        throw new Error('invalid parameter');\n      }\n\n      if (true === flg) {\n        this.style({\n          'position': 'fixed',\n          'z-index': 999\n        });\n      } else {\n        this.style({\n          position: null\n        }, 'fixed' === this.style('position') ? false : true);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border bottom color\n   *\n   * @param (mixed (color)) string: border bottom color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) stye option\n   * @return (string) border bottom color\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      return cmputl.color(this, \"border-bottom-color\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-header/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-input/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-input/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-comp-input/index.js\n * @brief input component for mofron\n *        This is component for form items.\n * @feature input text size is automatically changed when the height is changed.\n * @license MIT\n */\nconst FormItem = __webpack_require__(/*! mofron-comp-formitem */ \"./node_modules/mofron-comp-formitem/index.js\");\n\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst Border = __webpack_require__(/*! mofron-effect-border */ \"./node_modules/mofron-effect-border/index.js\");\n\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends FormItem {\n  /**\n   * constructor\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Input\");\n      this.shortForm(\"text\");\n      /* init config */\n\n      this.confmng().add(\"sizeOffset\", {\n        type: \"size\",\n        init: \"0.06rem\"\n      });\n      this.confmng().add(\"txtbuf\", {\n        type: \"string\"\n      });\n      this.confmng().add(\"type\", {\n        type: \"string\",\n        init: \"text\"\n      });\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      /* init input contents */\n\n      let inp = new mofron.class.Dom({\n        tag: \"input\",\n        component: this\n      });\n      this.childDom().child(inp);\n      this.childDom(inp);\n      this.styleDom(inp);\n      let pvt = {\n        private: true\n      };\n      this.effect(new Border(), pvt);\n\n      let fcs = (p1, p2) => {\n        try {\n          let txt = p1.text();\n\n          if (true === p2) {\n            this.confmng(\"txtbuf\", null === txt ? \"\" : txt);\n          } else if (txt !== this.confmng(\"txtbuf\")) {\n            let cevt = p1.changeEvent();\n\n            for (let cidx in cevt) {\n              cevt[cidx][0](p1, txt, cevt[cidx][1]);\n            }\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      this.confmng(\"focusEvent\", [fcs, true], pvt);\n      this.rootDom()[0].style({\n        'align-items': 'center'\n      });\n      /* set default size */\n\n      this.width(\"1.5rem\", pvt);\n      this.height(\"0.25rem\", pvt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  beforeRender() {\n    try {\n      super.beforeRender();\n\n      if (true === this.horizon()) {\n        this.label().size(comutl.sizediff(this.height(), this.sizeOffset()));\n      }\n    } catch (e) {}\n  }\n  /**\n   * input text setter/getter\n   *\n   * @param (string) input text\n   *                 undefined: call as getter\n   * @return (string) input text\n   * @type parameter\n   */\n\n\n  text(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return this.childDom().props(\"value\");\n      }\n      /* setter */\n\n\n      if (\"string\" !== typeof prm) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      this.childDom().props({\n        value: prm\n      });\n      let chg_evt = this.changeEvent();\n\n      for (let cidx in chg_evt) {\n        chg_evt[cidx][0](this, prm, chg_evt[cidx][1]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set font family\n   *\n   * @param (string) primary font name\n   *                 undefined: call as getter\n   * @param (string) secondary font name\n   * @return (array) font name [primary, secondary]\n   * @type parameter\n   */\n\n\n  font() {\n    try {\n      if (0 === arguments.length) {\n        /* getter */\n        return this.style(\"font-family\");\n      }\n      /* setter */\n\n\n      let set_fnt = \"\";\n\n      for (let aidx = 0; aidx < arguments.length; aidx++) {\n        if (\"string\" !== typeof arguments[aidx]) {\n          throw new Error(\"invalid parameter\");\n        }\n\n        set_fnt += arguments[aidx] + \",\";\n      }\n\n      set_fnt = set_fnt.substring(0, set_fnt.length - 1);\n      this.style({\n        \"font-family\": set_fnt\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * input value setter/getter\n   * this function is the same as 'text' function.\n   * \n   * @param (string) input text\n   *                 undefined: call as getter\n   * @return (string) input text\n   * @type parameter\n   */\n\n\n  value(prm) {\n    try {\n      if (undefined !== prm && \"string\" !== typeof prm) {\n        prm = prm + \"\";\n      }\n\n      return this.text(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * maximum input text length setter/getter\n   *\n   * @param (number) maximal length\n   *                 undefined: call as getter\n   * @return (mixed) number: maxmal length\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  maxlength(len) {\n    try {\n      if (undefined === len) {\n        /* getter */\n        return this.childDom().attrs('maxlength');\n      }\n      /* setter */\n\n\n      if ('number' !== typeof len) {\n        throw new Error('invalid parameter');\n      }\n\n      this.childDom().attrs({\n        maxlength: len\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * secret mode setter/getter\n   *\n   * @param (boolean) true: secret mode (input text is displayed in hiding.)\n   *                  false: normal mode\n   *                  undefined: call as getter\n   * @return (boolean) input mode\n   * @type parameter\n   */\n\n\n  secret(flg) {\n    try {\n      if (undefined === flg) {\n        /* getter */\n        return 'password' === this.type() ? true : false;\n      }\n      /* setter */\n\n\n      if ('boolean' !== typeof flg) {\n        throw new Error('invalid parameter');\n      }\n\n      this.type(true === flg ? 'password' : 'text');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * type attribute setter/getter\n   *\n   * @param (string) type value\n   *                 undefined: call as getter\n   * @return (mixed) type value\n   *                 null: not set\n   * @type private\n   */\n\n\n  type(prm) {\n    try {\n      this.confmng(\"type\", prm);\n      return this.childDom().attrs(undefined === prm ? \"type\" : {\n        \"type\": prm\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text color setter/getter\n   *\n   * @param (mixed (color)) string: text color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   *                        undefined: call as getter\n   * @param (key-value) style option\n   * @return (string) color\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      super.mainColor(prm);\n      return cmputl.color(this, \"color\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border color setter/getter\n   *\n   * @param (mixed (color)) string: border color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   *                        undefined: call as getter\n   * @param (key-value) style option\n   * @return (string) color\n   * @type parameter\n   */\n\n\n  accentColor(prm, opt) {\n    try {\n      super.accentColor(prm, opt);\n      return this.effect({\n        modname: \"Border\"\n      }).color(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * clear input text\n   *\n   * @type function\n   */\n\n\n  clear() {\n    try {\n      this.text('');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * focus status setter/getter\n   *\n   * @param (boolean) true: focus input\n   *                  false: defocus input\n   *                  undefined: call as getter\n   * @return (boolean) focus status\n   * @type parameter\n   */\n\n\n  focus(prm) {\n    try {\n      let ret = super.focus(prm);\n\n      if (true === prm && true === this.childDom().isPushed()) {\n        /* setter */\n        this.childDom().getRawDom().select();\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * input height setter/getter\n   * \n   * @param (string (size)) input height\n   *                        undefined: call as getter\n   * @param (key-value) style option\n   * @return (mixed) string: input height\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  height(prm, opt) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return comutl.sizesum(super.height(), this.sizeOffset());\n      }\n      /* setter */\n\n\n      let set_siz = comutl.sizediff(prm, this.sizeOffset());\n      super.height(set_siz, opt);\n      this.style({\n        \"font-size\": set_siz\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * input width setter/getter\n   *\n   * @param (string (size)) input width\n   *                        undefined: call as getter\n   * @param (key-value) style option\n   * @return (mixed) string: input width\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  width(prm, opt) {\n    try {\n      let siz = null;\n\n      if (undefined === prm) {\n        /* getter */\n        try {\n          return comutl.sizesum(super.width(), this.sizeOffset());\n        } catch (e) {\n          return super.width();\n        }\n      }\n      /* setter */\n\n\n      this.styleDom().style({\n        width: prm\n      }, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * size weight value setter/getter\n   * use for size calculate\n   * \n   * @param (string (size)) size weight\n   *                        undefined: call as getter\n   * @param (string (size)) size object for weight\n   * @type private\n   */\n\n\n  sizeOffset(prm) {\n    try {\n      return this.confmng(\"sizeOffset\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-input/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-modalfil/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-modalfil/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-comp-modalfil/index.js\n * @brief modal filter component for mofron\n *        apply a dim filter to the entire screen as when displaying a modal window\n * @feature modal windows can be easily implemented by adding child components to this component\n *          it is possible to make the back look like frosted glass (blur)\n * @attention default visible is false\n *            this component must be positioned to root for enabling the \"blur\" function\n *            other components that are the same hierarchy from this component are added [mofron-effect-blur](https://github.com/mofron/mofron-effect-blur.git).\n * @license MIT\n */\nconst Blur = __webpack_require__(/*! mofron-effect-blur */ \"./node_modules/mofron-effect-blur/index.js\");\n\nconst SyncWin = __webpack_require__(/*! mofron-effect-syncwin */ \"./node_modules/mofron-effect-syncwin/index.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * initialize component\n   *\n   * @param (mixed) blur prameter\n   *                key-value: component config\n   * @short blur\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname(\"ModalFil\");\n      this.shortForm(\"blur\");\n      /* init config */\n\n      this.confmng().add(\"blur\", {\n        type: \"size\",\n        init: \"0rem\"\n      });\n      this.confmng().add(\"speed\", {\n        type: \"number\",\n        init: 0\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      let pvt = {\n        private: true\n      };\n      this.effect(new SyncWin(), pvt);\n      this.style({\n        'position': 'fixed',\n        'z-index': '9999',\n        'top': '0rem',\n        'left': '0rem',\n        'display': 'none'\n      }, pvt);\n      /* set default color */\n\n      this.baseColor([240, 240, 240, 0.5], pvt);\n      this.styleDom().style().listener('display', this.switchBlur, this);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set blur effect\n   * \n   * @type private\n   */\n\n\n  beforeRender() {\n    try {\n      super.beforeRender();\n\n      if (null === this.parent() || \"0rem\" === this.blur()) {\n        return;\n      }\n\n      let pchd = this.parent().child();\n\n      for (let pc in pchd) {\n        if (this.id() !== pchd[pc].id()) {\n          pchd[pc].effect([new Blur({\n            value: this.blur(),\n            tag: \"ModalFil\",\n            speed: this.speed(),\n            eid: -1\n          }), new Blur({\n            value: \"0rem\",\n            tag: \"ModalFil\",\n            speed: this.speed(),\n            eid: -1\n          })]);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set backgrond color\n   *\n   * @param (mixed (color)) string: background color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (string) backgrond color\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      return this.baseColor(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set backgrond color\n   *\n   * @param (mixed (color)) string: background color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (key-value) style option\n   * @return (string) backgrond color\n   * @type parameter\n   */\n\n\n  baseColor(prm, opt) {\n    try {\n      let p_prm = undefined;\n\n      if (undefined !== prm) {\n        p_prm = comutl.getcolor(prm);\n        let rgba = p_prm.rgba();\n\n        if (1 === rgba[3] && (false === Array.isArray(prm) || undefined === prm[3])) {\n          p_prm.rgba(rgba[0], rgba[1], rgba[2], 0.5);\n        }\n      }\n\n      return super.baseColor(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * blur value\n   *\n   * @param (string (size)) blur value\n   * @param (number) blur speed (ms)\n   * @return (string) blur value\n   * @type parameter\n   */\n\n\n  blur(val, spd) {\n    try {\n      if (undefined !== spd) {\n        this.speed(spd);\n      }\n\n      return this.confmng(\"blur\", val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * blur speed\n   * \n   * @param (number) blur speed (ms)\n   * @return (number) blur speed (ms)\n   * @type parameter\n   */\n\n\n  speed(prm) {\n    try {\n      return this.confmng(\"speed\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * switch blur effect\n   * \n   * @param (mixed) after style value (string/null)\n   * @param (mixed) before style value (string/null)\n   * @type private\n   */\n\n\n  switchBlur(af, bf, cmp) {\n    try {\n      let pchd = cmp.parent().child();\n\n      for (let pc in pchd) {\n        if (cmp.id() !== pchd[pc].id()) {\n          let opt = {\n            name: \"Blur\",\n            tag: \"ModalFil\",\n            value: \"none\" === af ? \"0rem\" : cmp.blur()\n          };\n          let eff = pchd[pc].effect(opt);\n\n          if (true === comutl.isinc(eff, \"Blur\")) {\n            eff.execute();\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-modalfil/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-text/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-comp-text/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-comp-text/index.js\n * @brief text component for mofron\n * @license MIT\n */\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends mofron.class.Component {\n  /**\n   * constructor\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname('Text');\n      this.shortForm('text');\n      /* init config */\n\n      this.confmng().add(\"heiWeight\", {\n        init: 1.5,\n        type: \"number\"\n      });\n      this.confmng().add(\"weight\", {\n        type: \"number\",\n        select: [100, 200, 300, 400, 500, 600, 700, 800, 900]\n      });\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      this.text('');\n      this.size(\"0.16rem\", {\n        private: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text setter/getter\n   * \n   * @param (mixed) string: text value\n   *                undefined: call as getter\n   * @return (string) text value\n   * @type parameter\n   */\n\n\n  text(val) {\n    try {\n      return this.childDom().text(val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text getter\n   * \n   * @return (string) text value\n   * @type function\n   */\n\n\n  toString() {\n    try {\n      return this.text();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text size setter/getter\n   *\n   * @param (mixed) string (size): text size\n   *                undefined: call as getter\n   * @param (key-value) style option [not required]\n   * @return (mixed) string: text size (default is \"0.16rem\")\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  size(val, opt) {\n    try {\n      return cmputl.size(this, \"font-size\", val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text height setter/getter\n   * \n   * @param (mixed) string (size): text size\n   *                undefined: call as getter\n   * @param (key-value) style option [not required]\n   * @return (mixed) string: text height (default is \"0.24rem\")\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  height(prm, opt) {\n    try {\n      let siz = comutl.getsize(undefined === prm ? this.size() : prm);\n      let siz_buf = null;\n\n      if ('rem' === siz.type() || 'px' === siz.type()) {\n        if (undefined === prm) {\n          siz_buf = siz.value() * this.heiWeight();\n        } else {\n          siz_buf = siz.value() / this.heiWeight();\n        }\n\n        siz_buf = comutl.roundup(siz_buf) + siz.type();\n      } else {\n        siz_buf = siz.toString();\n      }\n\n      if (undefined === prm) {\n        /* gettter */\n        return siz_buf;\n      }\n\n      this.size(siz_buf, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * height weight setter/getter\n   * this value to make 'height' parameter and real dom size the same\n   * it needs to adjust depending on font difference.\n   * \n   * @param (mixed) number: height weight rate\n   *                undefined: call as getter\n   * @return (number) height weight rate\n   * @type private\n   */\n\n\n  heiWeight(prm) {\n    try {\n      return this.confmng(\"heiWeight\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text color setter/getter\n   * \n   * @param (mixed (color)) string: color name, #hex\n   *                array: [red, green, blue, (alpha)]\n   * @param (key-value) style option [not required]\n   * @return (mixed) string: text color\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  mainColor(val, opt) {\n    try {\n      return cmputl.color(this, 'color', val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text font setter/getter\n   * \n   * @param (mixed) string: font name (variable arguments)\n   *                undefined: call as getter\n   * @return (mixed) array: font name\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  font() {\n    try {\n      if (0 === arguments.length) {\n        /* getter */\n        return this.style(\"font-family\");\n      }\n      /* setter */\n\n\n      let set_fnt = \"\";\n\n      for (let aidx = 0; aidx < arguments.length; aidx++) {\n        if (\"string\" !== typeof arguments[aidx]) {\n          throw new Error(\"invalid parameter\");\n        }\n\n        set_fnt += arguments[aidx] + \",\";\n      }\n\n      set_fnt = set_fnt.substring(0, set_fnt.length - 1);\n      this.style({\n        \"font-family\": set_fnt\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * character spacing setter/getter\n   *\n   * @param (mixed) string(size): spacing size\n   *                undefined: call as getter\n   * @param (key-value) style option [not required]\n   * @return (mixed) string: spacing size\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  space(val, opt) {\n    try {\n      return cmputl.size(this, 'letter-spacing', val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text thickness setter/getter\n   *\n   * @param (mixed) number: thickness value [100-900]\n   *                null: delete thickness\n   *                undefined: call as getter\n   * @param (key-value) style option [not required]\n   * @return (number) thickness value\n   * @type parameter\n   */\n\n\n  weight(val, opt) {\n    try {\n      if (undefined === val) {\n        /* getter */\n        return this.style(\"font-weight\");\n      }\n      /* setter */\n\n\n      this.style({\n        'font-weight': val\n      }, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-text/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-ttlframe/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-ttlframe/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-comp-ttlframe/index.js\n * @brief title frame component\n * @author simpart\n */\nconst Frame = __webpack_require__(/*! mofron-comp-frame */ \"./node_modules/mofron-comp-frame/index.js\");\n\nconst Header = __webpack_require__(/*! mofron-comp-txtheader */ \"./node_modules/mofron-comp-txtheader/index.js\");\n\nmodule.exports = class extends Frame {\n  /**\n   * initialize component\n   * \n   * @param (mixed) text paramter\n   *                object: component option\n   * @param (component) child parameter\n   * @pmap text,child\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.name('TtlFrame');\n      this.shortForm('text', 'child');\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private \n   */\n\n\n  initDomConts() {\n    try {\n      this.header(new Header({\n        height: \"0.4rem\"\n      }));\n      super.initDomConts();\n      this.child(this.header());\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * header component\n   * \n   * @param (mofron-comp-txtheader) header component\n   * @return (mofron-comp-txtheader) header component\n   * @type parameter\n   */\n\n\n  header(prm) {\n    try {\n      if (undefined !== prm) {\n        prm.config({\n          bind: false\n        });\n      }\n\n      return this.innerComp('header', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * title text contents\n   * \n   * @param (mixed) string: title text\n   *                mofron-comp-text: text component\n   * @param (dict) text config\n   * @return (mofron-comp-text) text component\n   * @type parameter\n   */\n\n\n  text(prm, cnf) {\n    try {\n      return this.header().text(prm, cnf);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * title text contents\n   * same as text parameter\n   * \n   * @param (mixed) string: title text\n   *                mofron-comp-text: text component\n   * @param (string (size)) margin left size\n   * @return (mofron-comp-text) text component\n   * @type parameter\n   */\n\n\n  title(prm, lft) {\n    try {\n      return this.text(prm, {\n        style: {\n          \"margin-left\": lft\n        }\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * header background color\n   * \n   * @param (mixed (color)) string: color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @param (option) style option\n   * @return (string) header background color\n   * @type parameter\n   */\n\n\n  mainColor(prm, opt) {\n    try {\n      return this.header().baseColor(prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-ttlframe/index.js?");

/***/ }),

/***/ "./node_modules/mofron-comp-txtheader/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-txtheader/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  mofron-comp-txtheader/index.js\n * @brief text header component\n *        text in this component is positioned centrally in vertical in automatically. \n * @license MIT\n */\nconst Header = __webpack_require__(/*! mofron-comp-header */ \"./node_modules/mofron-comp-header/index.js\");\n\nconst Text = __webpack_require__(/*! mofron-comp-text */ \"./node_modules/mofron-comp-text/index.js\");\n\nconst Synhei = __webpack_require__(/*! mofron-effect-synchei */ \"./node_modules/mofron-effect-synchei/index.js\");\n\nconst cmputl = mofron.util.component;\nconst comutl = mofron.util.common;\nmodule.exports = class extends Header {\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component option\n   * @short text\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('TxtHeader');\n      this.shortForm('text');\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  initDomConts() {\n    try {\n      super.initDomConts();\n      this.style({\n        'align-items': 'center'\n      }, {\n        private: true\n      });\n      this.child(this.text());\n      this.text().effect(new Synhei(this));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter text\n   *\n   * @param (mixed) string: text contents\n   *                mofron-comp-text: update text component\n   * @param (key-value) text config\n   * @return (mofron-comp-text) text contents\n   * @type parameter\n   */\n\n\n  text(txt, cnf) {\n    try {\n      if (undefined !== cnf) {\n        if (true === comutl.isinc(txt, \"Text\")) {\n          txt.config(cnf);\n        } else {\n          this.text().config(cnf);\n        }\n      }\n\n      if ('string' === typeof txt) {\n        this.text().text(txt);\n        return;\n      }\n\n      return this.innerComp('text', txt, Text);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text position and size offset\n   * \n   * @param (string (size)) left offset position\n   * @param (string (size)) height offset position\n   * \n   */\n\n\n  txtpos(lft, hei) {\n    try {\n      this.text().style({\n        \"margin-left\": lft\n      });\n      let syn = this.text().effect({\n        name: \"SyncHei\"\n      });\n\n      if (true === comutl.isinc(syn, \"SyncHei\")) {\n        syn.offset(hei);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-txtheader/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-blur/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-effect-blur/index.js ***!
  \**************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-blur/index.js\n * @brief blur effect for mofron\n *        this effect makes the component to blurring.\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize blur effect\n   *\n   * @param (mixed) 'value' parameter\n   *                key-value: effect config\n   * @short value\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('Blur');\n      this.shortForm('value');\n      this.transition(\"filter\");\n      /* init config */\n\n      this.confmng().add(\"value\", {\n        type: \"size\",\n        init: \"0.05rem\"\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * enalbe blur effect\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  contents(tgt) {\n    try {\n      tgt.style({\n        'filter': 'blur(' + this.value() + ')'\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * blur size setter/getter\n   * \n   * @param (string) blur size (css value)\n   * @return (string) blur size\n   * @type parameter\n   */\n\n\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-blur/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-border/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-border/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-border/index.js\n * @brief border effect for mofron\n *        set border style to target component\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   * \n   * @param (mixed) width parameter\n   *                key-value: effect config\n   * @param (mixed) color parameter\n   * @short width,color\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Border');\n      this.shortForm('width', 'color');\n      this.transition([\"border-width\", \"border-top-width\", \"border-bottom-width\", \"border-left-width\", \"border-right-width\", \"border-top-left-width\", \"border-top-right-width\", \"border-bottom-left-width\", \"border-bottom-right-width\", \"border-color\", \"border-top-color\", \"border-bottom-color\", \"border-left-color\", \"border-right-color\", \"border-top-left-color\", \"border-top-right-color\", \"border-bottom-left-color\", \"border-bottom-right-color\"]);\n      /* init config */\n\n      this.confmng().add('width', {\n        type: 'size',\n        init: \"0.01rem\"\n      });\n      this.confmng().add('style', {\n        type: 'string',\n        init: 'solid',\n        select: ['none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted']\n      });\n      this.confmng().add('position', {\n        type: 'string',\n        init: 'all',\n        select: ['all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right']\n      });\n      this.confmng().add('color', {\n        type: 'color',\n        init: [90, 90, 90]\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effect config\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      let set_style = {};\n      let pos = 'all' === this.position() ? 'border-' : 'border-' + this.position() + '-';\n      set_style[pos + 'width'] = this.width().toString();\n      set_style[pos + 'style'] = this.style();\n      set_style[pos + 'color'] = this.color().toString();\n      cmp.style(set_style);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border width\n   * \n   * @param (string) css value of border width\n   * @return (string) css value of border width\n   * @type parameter\n   */\n\n\n  width(prm) {\n    try {\n      return this.confmng('width', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter border style\n   *\n   * @param (string) css value of border style (default is 'solid')\n   *                 ('none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted')\n   * @return (string) css value of border style\n   * @type parameter\n   */\n\n\n  style(prm) {\n    try {\n      return this.confmng('style', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border position\n   * \n   * @param (string) border target position (default is 'all')\n   *                 ('all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right')\n   * @return (string) css value of border type\n   * @type parameter\n   */\n\n\n  position(prm) {\n    try {\n      return this.confmng('position', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * border color\n   * \n   * @param (mixed (color)) string: color name, #hex\n   *                        array: [red, green, blue, (alpha)]\n   * @return (mixed (color)) border color\n   * @type parameter\n   */\n\n\n  color(prm) {\n    try {\n      return this.confmng('color', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-border/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-hrzpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-hrzpos/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-effect-hrzpos/index.js\n * @brief horizonal position effect for mofron component\n *        the component is positioned specified parameter that is 'center' or 'left' and 'right'.\n * @license MIT\n */\nconst cmputl = mofron.util.component;\nconst comutl = mofron.util.common;\n\nconst transfm = __webpack_require__(/*! mofron-util-transform */ \"./node_modules/mofron-util-transform/index.js\");\n\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   * \n   * @param (mixed) type parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short type,offset\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('HrzPos');\n      this.shortForm('type', 'offset');\n      /* init config */\n\n      this.confmng().add(\"offset\", {\n        type: \"size\"\n      });\n      this.confmng().add(\"type\", {\n        type: \"string\",\n        init: \"center\",\n        select: [\"center\", \"left\", \"right\"]\n      });\n      /* set config */\n\n      this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effect contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      let rdom = cmp.rootDom();\n\n      for (let ridx in rdom) {\n        if (true === comutl.isinc(cmp, \"Text\")) {\n          /* set text component position */\n          this.txtpos(rdom[ridx]);\n          continue;\n        }\n        /* set other component position */\n\n\n        let cmp_pos = rdom[ridx].style(\"position\");\n\n        if (\"center\" === this.type()) {\n          if (\"fixed\" === cmp_pos || \"absolute\" === cmp_pos) {\n            this.lftpos(rdom[ridx]);\n          } else {\n            rdom[ridx].style({\n              \"display\": \"block\"\n            });\n            this.mgnpos(rdom[ridx]);\n          }\n        } else {\n          if (\"relative\" === cmp_pos) {\n            this.mgnpos(rdom[ridx]);\n          } else if (\"absolute\" === cmp_pos || \"fixed\" === cmp_pos) {\n            this.lftpos(rdom[ridx]);\n          } else {\n            if (null !== cmp.parent()) {\n              rdom[ridx].style({\n                \"position\": \"relative\"\n              });\n              this.mgnpos(rdom[ridx]);\n            } else {\n              rdom[ridx].style({\n                \"position\": \"absolute\"\n              });\n              this.lftpos(rdom[ridx]);\n            }\n          }\n        }\n\n        if (\"flex\" === rdom[ridx].parent().style(\"display\") || \"flex\" === cmputl.dispbuff(rdom[ridx].parent())) {\n          break;\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * text component position\n   * \n   * @param (mofron.class.Dom) dom objedt\n   * @type private\n   */\n\n\n  txtpos(dom) {\n    try {\n      if (null !== dom.parent() && (\"flex\" === dom.parent().style(\"display\") || \"flex\" === cmputl.dispbuff(dom.parent()))) {\n        this.mgnpos(dom);\n      } else if (\"absolute\" === dom.style(\"position\") || \"flex\" === dom.style(\"position\")) {\n        this.lftpos(dom);\n      } else {\n        dom.style({\n          'text-align': this.type()\n        });\n\n        if (null !== this.offset()) {\n          dom.style({\n            \"position\": \"relative\"\n          });\n\n          if (\"right\" !== this.type()) {\n            dom.style({\n              \"left\": this.offset()\n            });\n          } else {\n            dom.style({\n              \"right\": this.offset()\n            });\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set margin position\n   * \n   * @param (mofron.class.Dom) dom object\n   * @type private\n   */\n\n\n  mgnpos(dom) {\n    try {\n      let off = this.offset();\n\n      if ('center' === this.type()) {\n        dom.style({\n          \"margin-right\": \"auto\",\n          \"margin-left\": \"auto\"\n        });\n\n        if (null !== off) {\n          dom.style({\n            \"position\": \"relative\",\n            \"left\": off\n          });\n        }\n      } else if ('left' === this.type()) {\n        dom.style({\n          \"margin-right\": \"auto\",\n          \"margin-left\": \"0rem\"\n        });\n\n        if (null !== off) {\n          dom.style({\n            \"margin-left\": off\n          });\n        }\n      } else {\n        dom.style({\n          \"margin-right\": \"0rem\",\n          \"margin-left\": \"auto\"\n        });\n\n        if (null !== off) {\n          dom.style({\n            \"margin-right\": off\n          });\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set left position\n   *\n   * @param (mofron.class.Dom) dom object\n   * @type private\n   */\n\n\n  lftpos(dom) {\n    try {\n      let off = this.offset();\n\n      if ('center' === this.type()) {\n        dom.style({\n          \"left\": \"50%\"\n        });\n\n        if (null === off || \"%\" !== comutl.sizetype(off)) {\n          transfm(dom, \"-50%\");\n        } else {\n          transfm(dom, comutl.sizesum(\"-50%\", off));\n        }\n      } else if ('left' === this.type()) {\n        dom.style({\n          \"left\": null !== off ? off : \"0rem\"\n        });\n      } else if ('right' === this.type()) {\n        dom.style({\n          \"right\": null !== off ? off : \"0rem\"\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * position type setter/getter\n   * \n   * @param (string) set position type ('center','left','right')\n   *                 undefind: call as getter\n   * @return (string) position type\n   * @type parameter\n   */\n\n\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * position offset setter/getter\n   * \n   * @param (string(size)) position offset size\n   *                       undefined: call as getter\n   * @return (mixed) string(size): position offset size\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  offset(prm) {\n    try {\n      return this.confmng(\"offset\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-hrzpos/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-radius/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-radius/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-radius/index.js\n * @brief radius effect for mofron\n *        this effect makes the components of outside rounded style\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize radius effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @short value\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('Radius');\n      this.shortForm('value');\n      /* init config */\n\n      this.confmng().add(\"value\", {\n        type: \"size\",\n        init: \"0.5rem\"\n      });\n      this.confmng().add(\"position\", {\n        list: true,\n        select: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n      });\n      this.transition([\"border-radius\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-bottom-left-radius\", \"border-bottom-right-radius\"]);\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * radius size\n   *\n   * @param (string (size)) radius size\n   * @return (string (size)) radius size\n   * @type parameter\n   */\n\n\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * radius target position\n   * each position will be targeted if nothing is set \n   * \n   * @param (mixed) array: position list\n   *                string: target position (\"top-left\",\"top-right\",\"bottom-left\",\"bottom-right\")\n   * @return (array) position list\n   * @type parameter\n   */\n\n\n  position(prm) {\n    try {\n      return this.confmng('position', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effect contents\n   * \n   * @param (component) target component\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      let pos = this.position();\n      let val = this.value().toString();\n\n      if (0 === pos.length) {\n        cmp.style({\n          'border-radius': val\n        }, {\n          bpref: true\n        });\n      } else {\n        let set_sty = {};\n\n        for (let tidx in pos) {\n          set_sty['border-' + pos[tidx] + '-radius'] = val;\n        }\n\n        cmp.style(set_sty, {\n          bpref: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-radius/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-shadow/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-shadow/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-shadow/index.js\n * @brief shadow effect for mofron\n *        this effect makes the component has a shadow.\n * @feature the size changes according to the value of the 'value' parameter.\n *          the blur percentage changes according to the value of the 'blur' parameter.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @param color parameter\n   * @short value,color\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Shadow');\n      this.shortForm('value', 'color');\n      this.transition([\"box-shadow\", \"webkit-box-shadow\", \"-moz-box-shadow\", \"-o-box-shadow\", \"-ms-box-shadow\"]);\n      /* init config */\n\n      this.confmng().add(\"value\", {\n        type: \"size\",\n        init: \"0.015rem\"\n      });\n      this.confmng().add(\"blur\", {\n        type: \"size\",\n        init: \"0rem\"\n      });\n      this.confmng().add('color', {\n        type: \"color\",\n        init: [190, 190, 190]\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * shadow size\n   *\n   * @param (string (size)) shadow size (css value)\n   * @return (string (size)) shadow size (css value)\n   * @type parameter\n   */\n\n\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * blur size value\n   * \n   * @param (string (size)) blur size value\n   * @return (string (size)) blur size value\n   * @type parameter\n   */\n\n\n  blur(prm) {\n    try {\n      return this.confmng(\"blur\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * shadow color\n   *\n   * @param (string (size)) shadow color (css value)\n   * @return (string (size)) shadow color (css value)\n   * @type parameter\n   */\n\n\n  color(prm) {\n    try {\n      return this.confmng(\"color\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effect contents\n   * \n   * @param (component) target componet\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      let str_val = this.value().toString();\n      let sum_val = comutl.sizesum(str_val, comutl.sizesum(str_val, str_val));\n      let set_val = {\n        \"box-shadow\": sum_val + ' ' + sum_val + ' ' + this.blur().toString() + ' ' + '0rem ' + this.color().toString()\n      };\n      cmp.style(set_val, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-shadow/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-synchei/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-synchei/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-synchei/index.js\n * @brief synchronize height of target component and height of effect component\n *        this effect resizes height of a target component when the height of the target component changed.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * constructor\n   * \n   * @param (mixed) string: targetComp parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short targetComp,offset\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('SyncHei');\n      this.shortForm('targetComp', 'offset');\n      /* init config */\n\n      this.confmng().add('targetComp', {\n        type: 'Component'\n      });\n      this.confmng().add('offset', {\n        type: 'size'\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter for height listen target component\n   * it triggers this effect when height of target component was changed.\n   *\n   * @param (mofron.class.Component) target component\n   *                                 undefined: call as getter\n   * @return (mixed) mofron.class.Component: target component\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  targetComp(prm) {\n    try {\n      let ret = this.confmng('targetComp', prm);\n\n      if (undefined !== prm) {\n        let syn_fnc = (p1, p2, sync) => {\n          try {\n            sync.execute();\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        prm.styleDom().style().listener('height', syn_fnc, this);\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * offset value setter/getter\n   * this value is used for height adjustment\n   *\n   * @param (string(size)) offset value (default is '0rem')\n   *                       undefined: call as getter\n   * @return (string) offset value\n   * @type parameter\n   */\n\n\n  offset(prm) {\n    try {\n      return this.confmng('offset', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * synchronize height size\n   *\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      if (null === this.targetComp()) {\n        this.targetComp(this.component().parent());\n      }\n\n      cmp.height(comutl.sizesum(this.targetComp().height(), this.offset()));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-synchei/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-syncwid/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-syncwid/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-syncwid/index.js\n * @brief synchronize width of target component and width of effect component\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   *\n   * @param (mixed) targetComp config parameter\n   *                dict: effect config list\n   * @param (string(size)) offset config parameter\n   * @short targetComp,offset\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.shortForm('targetComp', 'offset');\n      this.modname('SyncWid');\n      /* init config */\n\n      this.confmng().add(\"targetComp\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"offset\", {\n        type: \"size\"\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter for width listen target component \n   * it triggers this effect when width of target component was changed.\n   *\n   * @param (Component) target component\n   *                    undefined: call as getter\n   * @return (mixed) Component: target component\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  targetComp(prm) {\n    try {\n      let ret = this.confmng(\"targetComp\", prm);\n\n      if (undefined !== prm) {\n        let syn_fnc = (p1, p2, sync) => {\n          try {\n            sync.execute();\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        prm.styleDom().style().listener('width', syn_fnc, this);\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * offset value setter/getter\n   * this value is used for width adjustment\n   *\n   * @param (string(size)) offset value (default is '0rem')\n   *                       undefined: call as getter\n   * @return (mixed) string: offset value\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  offset(prm) {\n    try {\n      return this.confmng('offset', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effect contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      if (null === this.targetComp()) {\n        this.targetComp(this.component().parent());\n      }\n\n      cmp.width(comutl.sizesum(this.targetComp().width(), this.offset()));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-syncwid/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-syncwin/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-syncwin/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-effect-syncwin/index.js\n * @brief synchronize component with window\n *        target component size is changed even if the window size is changed.\n * @license MIT\n */\nconst comutl = mofron.util.common;\n\nlet get_offsiz = off => {\n  try {\n    let ret = [];\n\n    for (let oidx in off) {\n      if (null === off[oidx]) {\n        ret.push(undefined);\n        continue;\n      }\n\n      let siz = comutl.getsize(off[oidx]);\n\n      if ('%' === siz.type()) {\n        let oval = siz.value() / 100;\n        ret.push(0 == oidx ? window.innerWidth * oval + \"px\" : window.innerHeight * oval + \"px\");\n      } else {\n        ret.push(siz.toPixel() + 'px');\n      }\n    }\n\n    return ret;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize effect\n   * \n   * @param (mixed) valid config parameter\n   *                dict: effect config list\n   * @param (mixed) offset config parameter\n   * @short valid,offset\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('SyncWin');\n      this.shortForm('valid', 'offset');\n      /* init config */\n\n      this.confmng().add(\"x_valid\", {\n        type: \"boolean\",\n        init: true\n      });\n      this.confmng().add(\"y_valid\", {\n        type: \"boolean\",\n        init: true\n      });\n      this.confmng().add(\"x_offset\", {\n        type: \"size\"\n      });\n      this.confmng().add(\"y_offset\", {\n        type: \"size\"\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * enable synchronize window size\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  contents(tgt) {\n    try {\n      let off = get_offsiz(this.offset());\n\n      if (true === this.valid()[0]) {\n        /* set horizon size */\n        try {\n          tgt.width(comutl.sizesum(window.innerWidth + 'px', off[0]));\n        } catch (e) {\n          tgt.width(window.innerWidth + 'px');\n        }\n      }\n\n      if (true === this.valid()[1]) {\n        /* set vertical size */\n        try {\n          tgt.height(comutl.sizesum(window.innerHeight + 'px', off[1]));\n        } catch (e) {\n          tgt.height(window.innerHeight + 'px');\n        }\n      }\n\n      if (false === this.isInited()) {\n        let fnc = eff => {\n          try {\n            eff.execute();\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        mofron.window.resizeEvent(fnc, this);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set x,y valid flag\n   * \n   * @param (boolean) valid flag for horizon\n   * @param (boolean) valid flag for vertical\n   * @return (array) [x-flag, y-flag ]\n   * @type pararmeter\n   */\n\n\n  valid(x, y) {\n    try {\n      if (undefined === x) {\n        /* getter */\n        return [this.x_valid(), this.y_valid()];\n      }\n      /* setter */\n\n\n      this.x_valid(x);\n      this.y_valid(y);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * horizonal valid flag setter/getter\n   * \n   * @param (boolean) true: enabled horizonal sync [default]\n   *                  false: disabled horizonal sync\n   *                  undefined: call as getter\n   * @return (boolean) horizonal valid flag\n   * @type parameter\n   */\n\n\n  x_valid(prm) {\n    try {\n      return this.confmng(\"x_valid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * vertical valid flag setter/getter\n   * \n   * @param (boolean) true: enabled vertical sync [default]\n   *                  false: disabled vertical sync\n   *                  undefined: call as getter\n   * @return (boolean) vertival valid flag\n   * @type parameter\n   */\n\n\n  y_valid(prm) {\n    try {\n      return this.confmng(\"y_valid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter offset size\n   * \n   * @param (string (size)) horizonal offset size\n   * @param (string (size)) vertical offset size\n   * @return (array) [horizon offset size, vertical offset size]\n   * @type parameter\n   */\n\n\n  offset(x, y) {\n    try {\n      if (undefined === x) {\n        /* getter */\n        return [this.x_offset(), this.y_offset()];\n      }\n      /* setter */\n\n\n      this.x_offset(x);\n      this.y_offset(y);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * horizonal offset size setter/getter\n   * \n   * @param (string(size)) horizonal offset size\n   * @return (string(size)) horizonal offset size\n   * @type parameter\n   */\n\n\n  x_offset(prm) {\n    try {\n      return this.confmng(\"x_offset\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * vertical offset size setter/getter\n   * \n   * @param (string(size)) vertical offset size\n   * @return (string(size)) vertical offset size\n   * @type parameter\n   */\n\n\n  y_offset(prm) {\n    try {\n      return this.confmng(\"y_offset\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-syncwin/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-synwhei/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-synwhei/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-effect-synwhei/index.js\n * @brief syncronize component height to window height\n * @license MIT\n */\nconst Syncwin = __webpack_require__(/*! mofron-effect-syncwin */ \"./node_modules/mofron-effect-syncwin/index.js\");\n\nmodule.exports = class extends Syncwin {\n  /**\n   * initialize effect\n   * \n   * @param (mixed) y_offset parameter\n   *                dict: effect config\n   * @param (prm) offset parameter\n   * @short y_offset\n   * @type private\n   */\n  constructor(p1) {\n    try {\n      super();\n      this.modname('Synwhei');\n      this.shortForm('y_offset');\n      this.valid(false, true);\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-synwhei/index.js?");

/***/ }),

/***/ "./node_modules/mofron-effect-vrtpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-vrtpos/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-effect-vrtpos/index.js\n * @brief vertical position effect for mofron component\n *        the component is positioned specified parameter that is 'center' or 'top' and 'bottom'.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\n\nconst transfm = __webpack_require__(/*! mofron-util-transform */ \"./node_modules/mofron-util-transform/index.js\");\n\nmodule.exports = class extends mofron.class.Effect {\n  /**\n   * initialize vertical position effect\n   *\n   * @param (mixed) type config parameter\n   *                key-value: effect config list\n   * @param offset config parameter\n   * @short type,offset\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname(\"VrtPos\");\n      this.shortForm(\"type\", \"offset\");\n      /* init config */\n\n      this.confmng().add(\"type\", {\n        type: \"string\",\n        select: [\"top\", \"center\", \"bottom\"],\n        init: \"center\"\n      });\n      this.confmng().add(\"offset\", {\n        type: \"size\"\n      });\n      /* set config */\n\n      this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * effet contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  contents(cmp) {\n    try {\n      let rdom = cmp.rootDom();\n\n      for (let ridx in rdom) {\n        if (true === comutl.isinc(cmp, \"Text\")) {\n          this.txtpos(rdom[ridx]);\n          return;\n        } else if (\"absolute\" === rdom[ridx].style(\"position\") || \"relative\" === rdom[ridx].style(\"position\") || \"fixed\" === rdom[ridx].style(\"position\")) {\n          this.toppos(rdom[ridx]);\n        } else if (\"flex\" === rdom[ridx].parent().style(\"display\") || \"flex\" === cmputl.dispbuff(rdom[ridx])) {\n          this.mgnpos(rdom[ridx]);\n        } else {\n          rdom[ridx].style({\n            \"position\": \"relative\"\n          }, {\n            passive: true\n          });\n          this.toppos(rdom[ridx]);\n        }\n\n        if (\"flex\" !== rdom[ridx].parent().style(\"display\")) {\n          break;\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set text component position\n   * \n   * @param (mofron.class.Dom) dom object\n   * @type private\n   */\n\n\n  txtpos(dom) {\n    try {\n      let off = this.offset();\n      let pnt = dom.parent();\n\n      if (null !== pnt) {\n        let pnt_disp = \"none\" === pnt.style(\"display\") ? cmputl.dispbuff(pnt) : pnt.style(\"display\");\n\n        if (\"flex\" === pnt_disp || 'grid' === pnt_disp) {\n          if (\"center\" === this.type()) {\n            pnt.style({\n              \"align-items\": \"center\"\n            });\n          } else if (\"bottom\" === this.type()) {\n            pnt.style({\n              \"align-items\": \"flex-end\"\n            });\n          }\n\n          if (null !== off) {\n            dom.style({\n              \"position\": \"relative\"\n            }, {\n              passive: true\n            });\n            dom.style({\n              \"top\": off\n            });\n          }\n\n          return;\n        }\n      }\n\n      dom.style({\n        \"position\": \"relative\"\n      }, {\n        passive: true\n      });\n      this.toppos(dom);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set position by top value\n   * \n   * @param (mofron.class.Dom) effect target component\n   * @type private\n   */\n\n\n  toppos(dom) {\n    try {\n      let off = this.offset();\n\n      if (\"center\" === this.type()) {\n        dom.style({\n          \"top\": \"50%\"\n        });\n        transfm(dom, undefined, \"-50%\");\n\n        if (null !== off) {\n          dom.style({\n            \"margin-top\": off\n          });\n        }\n      } else if (\"top\" === this.type()) {\n        dom.style({\n          \"top\": null !== off ? off : \"0rem\"\n        });\n      } else {\n        dom.style({\n          \"bottom\": null !== off ? off : \"0rem\"\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set position by margin value\n   * \n   * @param (mofron.class.Dom) dom object\n   * @type private\n   */\n\n\n  mgnpos(dom) {\n    try {\n      let off = this.offset();\n\n      if (\"center\" === this.type()) {\n        dom.style({\n          \"margin-top\": \"auto\",\n          \"margin-bottom\": \"auto\"\n        });\n\n        if (null !== off) {\n          dom.style({\n            \"position\": \"relative\"\n          }, {\n            passive: true\n          });\n          dom.style({\n            \"top\": off\n          });\n        }\n      } else if (\"top\" === this.type()) {\n        dom.style({\n          \"margin-top\": null !== off ? off : \"0rem\",\n          \"margin-bottom\": \"auto\"\n        });\n      } else {\n        dom.style({\n          \"margin-top\": \"auto\",\n          \"margin-bottom\": null !== off ? off : \"0rem\"\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * position type setter/getter\n   *\n   * @param (string) position type (center,top,bottom)\n   *                 undefined: call as getter\n   * @return (string) position type\n   * @type parameter\n   */\n\n\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * offset size setter/getter\n   *\n   * @param (string(size)) offset size\n   *                       undefined: call as getter\n   * @return (mofron.class.Size) offset size\n   * @type parameter\n   */\n\n\n  offset(prm) {\n    try {\n      return this.confmng(\"offset\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-vrtpos/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-click/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-event-click/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-event-click/index.js\n * @brief click event for mofron component\n *        it executes an event function when the component is clicked\n * ## event function parameter\n *  - component: event target component object\n *  - object: MouseEvent object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nconst Common = __webpack_require__(/*! mofron-event-common */ \"./node_modules/mofron-event-common/index.js\");\n\nmodule.exports = class extends Common {\n  /**\n   * initialize click event\n   * \n   * @param (mixed) listener parameter\n   *                key-value: event config\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Click\");\n      this.shortForm(\"listener\");\n      /* init config */\n\n      this.confmng().add(\"pointer\", {\n        type: \"boolean\",\n        init: true\n      });\n      this.type(\"click\");\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * add click event to target component.\n   * \n   * @param (component) event target component\n   * @type private\n   */\n\n\n  contents(tgt) {\n    try {\n      super.contents(tgt);\n\n      if (true === this.pointer()) {\n        this.component().style({\n          'cursor': 'pointer'\n        }, {\n          passive: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * mouse cursor style\n   *\n   * @param (boolean) true: mouse-in cursor is pointer [default]\n   *                  false: mouse-in coursor is default\n   * @return (boolean) mouse-in cursor style\n   * @type parameter\n   */\n\n\n  pointer(flg) {\n    try {\n      return this.confmng(\"pointer\", flg);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-click/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-clkfocus/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-event-clkfocus/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-event-clkfocus/index.js\n * @brief click focus event for mofron\n * ## event function parameter\n *  - component: event target component object\n *  - boolean: focus flag\n *  - mixed: user specified parameter\n * @feature this event notify when enable focus by clicking component and disable focus by clicking the other than that.\n * @attention not supported focus event by tab key\n * @license MIT\n */\nconst Click = __webpack_require__(/*! mofron-event-click */ \"./node_modules/mofron-event-click/index.js\");\n\nmodule.exports = class extends Click {\n  /**\n   * initialize event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.name('ClkFocus');\n      /* init config */\n\n      this.confmng().add(\"clickFlag\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"status\", {\n        type: \"boolean\",\n        init: false\n      });\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event contents for target component\n   * \n   * @param (mofron.class.Dom) target dom object\n   * @type private\n   */\n\n\n  contents(tgt_dom) {\n    try {\n      if (true === this.pointer()) {\n        tgt_dom.component().style({\n          \"cursor\": \"pointer\"\n        });\n      }\n\n      let evt = this;\n      tgt_dom.getRawDom().addEventListener('click', () => {\n        try {\n          evt.clickFlag(true);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      }, false);\n\n      let win_clk = () => {\n        try {\n          if (true === evt.status() && false === evt.clickFlag()) {\n            evt.execListener(false);\n            evt.status(false);\n          } else if (false === evt.status() && true === evt.clickFlag()) {\n            evt.execListener(true);\n            evt.status(true);\n          }\n\n          evt.clickFlag(false);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      mofron.window.event(new Click(win_clk));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * flag for target clicked\n   *\n   * @param (boolean) click flag\n   * @return (boolean) click flag\n   * @type private\n   */\n\n\n  clickFlag(prm) {\n    try {\n      return this.confmng(\"clickFlag\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * focus status flag setter/getter\n   *\n   * @param (boolean) focus status flag\n   *                  undefined: call as getter\n   * @return (boolean) focus status flag\n   * @type function\n   */\n\n\n  status(prm) {\n    try {\n      return this.confmng(\"status\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-clkfocus/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-common/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-event-common/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-event-common/index.js\n * @brief common event for mofron\n *        set addEventListener of target object\n *        it is possible to use addEventListener() for general by setting the parameter of the type method.\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Event {\n  /**\n   * initialize common event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @short listener,type\n   * @type private\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Common\");\n      this.shortForm(\"listener\", \"type\");\n      /* init config */\n\n      this.confmng().add(\"type\", {\n        type: \"string\"\n      });\n      /* set config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event type\n   * \n   * @param (string) event type\n   * @return (string) event type\n   * @type parameter\n   */\n\n\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event contents\n   * \n   * @param (mofron.class.Dom) event target dom\n   * @type private\n   */\n\n\n  contents(tgt_dom) {\n    try {\n      let evt_obj = this;\n      tgt_dom.getRawDom().addEventListener(this.type(), e => {\n        try {\n          evt_obj.execListener(e);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      }, false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-common/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-oncommon/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-event-oncommon/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-event-oncommon/index.js\n * @brief on-event common module for mofron\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object (depend on 'ename' parameter)\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Event {\n  /**\n   * initialize event\n   * \n   * @param (mixed) listener config parameter\n   *                key-value: event config list\n   * @param (string) ename config parameter\n   * @short listener,ename\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('OnCommon');\n      this.shortForm(\"listener\", \"ename\");\n      /* init config */\n\n      this.confmng().add(\"ename\", {\n        type: \"string\"\n      });\n      /* add config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event name setter/getter\n   * \n   * @param (string) event name\n   *                 undefined: call as getter\n   * @return (string) event name\n   * @type parameter\n   */\n\n\n  ename(prm) {\n    try {\n      return this.confmng(\"ename\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * event contents\n   * \n   * @param (mofron.class.Dom) event target dom\n   * @type private\n   */\n\n\n  contents(tgt_dom) {\n    try {\n      let ename = this.ename();\n\n      if (null === ename || undefined === tgt_dom.getRawDom()[ename]) {\n        throw new Error('invalid event name : ' + ename);\n      }\n\n      let evt_obj = this;\n      let evt_buff = tgt_dom.getRawDom()[ename];\n\n      tgt_dom.getRawDom()[ename] = ev => {\n        try {\n          if (\"function\" === typeof evt_buff) {\n            evt_buff(ev);\n          }\n\n          evt_obj.execListener(ev);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-oncommon/index.js?");

/***/ }),

/***/ "./node_modules/mofron-event-visiclick/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mofron-event-visiclick/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file mofron-event-visiclick/index.js\n * @brief visible switch click event for mofron\n * @license MIT\n */\nconst Click = __webpack_require__(/*! mofron-event-click */ \"./node_modules/mofron-event-click/index.js\");\n\nmodule.exports = class extends Click {\n  /**\n   * initilize event\n   *\n   * @param (mixed) dict: event option\n   *                string: visible mode\n   * @param (Component) target component\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.name('VisiClick');\n      this.shortForm('mode', 'tgtComp');\n      /* init config */\n\n      this.confmng().add(\"callback\", {\n        type: \"function\"\n      });\n      this.confmng().add(\"tgtComp\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"mode\", {\n        type: \"string\",\n        init: \"switch\"\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * add click event to target component.\n   *\n   * @param (component) event target component\n   * @type private\n   */\n\n\n  contents(tgt_dom) {\n    try {\n      super.contents(tgt_dom);\n      this.listener((tgt, ev, vs) => {\n        try {\n          if ('enable' === vs.mode()) {\n            vs.tgtComp().visible(true, this.callback());\n          } else if ('disable' === vs.mode()) {\n            vs.tgtComp().visible(false, this.callback());\n          } else if ('destroy' === vs.mode()) {\n            vs.tgtComp().destroy(this.tgtParam());\n          } else if ('switch' === vs.mode()) {\n            vs.tgtComp().visible(!vs.tgtComp().visible(), this.callback());\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      }, this);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * target component setter/getter\n   *\n   * @param (mixed) Component: set visible target component\n   *                undefined: call as getter\n   * @return (Component) visible target component\n   * @type parameter\n   */\n\n\n  tgtComp(prm) {\n    try {\n      let ret = this.confmng(\"tgtComp\", prm);\n      return null === ret ? this.component() : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * callback function for switch\n   * \n   * @param (function) callback function\n   *                   undefined: call as getter\n   * @return (function) callback function\n   * @type parameter\n   */\n\n\n  callback(prm) {\n    try {\n      let ret = this.confmng(\"callback\", prm);\n      return null === ret ? undefined : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * visible mode setter/getter\n   *\n   * @param (string) visible mode ('enable', 'disable', 'switch')\n   *                 undefined: call as getter\n   * @return (string) visible mode\n   * @type parameter\n   */\n\n\n  mode(prm) {\n    try {\n      return this.confmng(\"mode\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-visiclick/index.js?");

/***/ }),

/***/ "./node_modules/mofron-layout-horizon/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-layout-horizon/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-layout-horizon/index.js\n * @brief horizon layout for mofron\n *        target component of children is positioned horizontally.\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Layout {\n  /**\n   * initialize layout\n   * \n   * @type private\n   */\n  constructor() {\n    try {\n      super();\n      this.modname('Horizon');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set horizon style\n   *\n   * @type private\n   */\n\n\n  execute() {\n    try {\n      this.component().style({\n        'display': '-webkit-flex',\n        'display': 'flex'\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-horizon/index.js?");

/***/ }),

/***/ "./node_modules/mofron-layout-hrzcenter/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron-layout-hrzcenter/index.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-layout-hrzcenter/index.js\n * @brief horizon center layout\n * @license MIT\n */\nmodule.exports = class extends mofron.class.Layout {\n  /**\n   * initialize horizon center layout\n   * \n   * @param (mixed) object: layout option\n   *                number: center rate\n   * @param (string) center type\n   * @short rate,type\n   * @type private\n   */\n  constructor(po, p2) {\n    try {\n      super();\n      this.name('HrzCenter');\n      this.shortForm('rate', 'type');\n      this.confmng().add('rate', {\n        type: 'number',\n        init: 80\n      });\n      this.confmng().add('type', {\n        type: 'string',\n        select: ['relative', 'margin', 'padding'],\n        init: 'relative'\n      });\n\n      if (0 < arguments.length) {\n        this.config(po, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * layout contents\n   *\n   * @type private\n   */\n\n\n  contents(idx, tgt) {\n    try {\n      let tdom = tgt.rootDom();\n      let pdom = tgt.rootDom()[0].parent();\n\n      if (null !== pdom && \"flex\" === pdom.style(\"display\")) {\n        tdom = [tgt.rootDom()[0]];\n      }\n\n      if ('relative' === this.type()) {\n        for (let tidx in tdom) {\n          tdom[tidx].style({\n            position: this.type(),\n            left: (100 - this.rate()) / 2 + '%',\n            width: this.rate() + '%'\n          });\n        }\n      } else {\n        let set_style = {\n          width: this.rate() + '%'\n        };\n        set_style[this.type() + '-left'] = (100 - this.rate()) / 2 + '%';\n\n        for (let tidx in tdom) {\n          tdom[tidx].style(set_style);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter center rate\n   *\n   * @param (number) center rate \n   *                 undefined: call as getter\n   * @return (number) center rate\n   * @type parameter\n   */\n\n\n  rate(prm) {\n    try {\n      if (undefined !== prm && (0 > prm || 100 < prm)) {\n        throw new Error('invalid parameter');\n      }\n\n      return this.confmng(\"rate\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * setter/getter center type\n   *\n   * @param (string) center type\n   *                 undefined: call as getter\n   * @return (string) center type\n   * @type parameter\n   */\n\n\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-hrzcenter/index.js?");

/***/ }),

/***/ "./node_modules/mofron-layout-margin/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-layout-margin/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-layout-margin/index.js\n * @brief margin layout of mofron\n *        target child component is got margin style.\n * @license MIT\n */\nconst cmputl = mofron.util.component;\nmodule.exports = class extends mofron.class.Layout {\n  /**\n   * initialize margin layout\n   *\n   * @param (mixed) type config parameter\n   *                dict: layout config list\n   * @param (string(size)) value config parameter\n   * @short type,value\n   * @type private\n   */\n  constructor(p1, p2) {\n    try {\n      super();\n      this.modname('Margin');\n      this.shortForm('type', 'value');\n      /* init config */\n\n      this.confmng().add('type', {\n        type: 'string',\n        select: ['top', 'right', 'bottom', 'left']\n      });\n      this.confmng().add('value', {\n        type: 'size',\n        init: '0.25rem'\n      });\n      /* set config */\n\n      if (0 < arguments.length) {\n        this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * margin layout\n   *\n   * @type private\n   */\n\n\n  contents(idx, tgt) {\n    try {\n      let mg = null === this.type() ? 'margin' : 'margin' + '-' + this.type();\n      let setmgn = {};\n      setmgn[mg] = this.value();\n      cmputl.rstyle(tgt, setmgn);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * margin type setter/getter\n   *\n   * @param (string) margin type ('top', 'right', 'bottom', 'left')\n   *                 undefined: call as getter\n   * @return (string) margin type\n   * @attention it's enable for all directions of margin if the type is null.\n   * @type parameter\n   */\n\n\n  type(prm) {\n    try {\n      return this.confmng('type', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * margin size value setter/getter\n   *\n   * @param (string(size)) margin size\n   *                       undefined: call as getter\n   * @return (string(size)) margin size\n   * @type parameter\n   */\n\n\n  value(prm) {\n    try {\n      return this.confmng('value', prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-margin/index.js?");

/***/ }),

/***/ "./node_modules/mofron-util-transform/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-util-transform/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file mofron-transform/index.js\n * @brief css transform util functions for mofron\n * @license MIT\n */\nmodule.exports = (prm, x, y, z) => {\n  try {\n    let set = (sx, sy, sz) => {\n      try {\n        let set_val = null;\n\n        if (undefined !== sx && undefined !== sy && undefined !== sz) {\n          set_val = \"translate3d(\" + sx + \",\" + sy + \",\" + sz + \")\";\n        }\n\n        if (undefined !== sx && undefined !== sy) {\n          set_val = \"translate(\" + sx + \",\" + sy + \")\";\n        } else if (undefined !== sx) {\n          set_val = \"translateX(\" + sx + \")\";\n        } else if (undefined !== sy) {\n          set_val = \"translateY(\" + sy + \")\";\n        } else {\n          set_val = \"translateZ(\" + sz + \")\";\n        }\n\n        prm.style({\n          \"transform\": set_val\n        }, {\n          bpref: true\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    };\n\n    let get = gprm => {\n      try {\n        if (-1 !== gprm.indexOf(\"translate3d\")) {\n          return gprm.substring(\"translate3d\".length - 1, gprm.length - 1).split(',');\n        } else if (-1 === gprm.indexOf(\"translate\")) {\n          return [undefined, undefined, undefined];\n        }\n\n        let sp_prm = gprm.split(\"translate\")[1];\n\n        if ('X' === sp_prm[0]) {\n          return [sp_prm.substring(2, sp_prm.length - 1), undefined, undefined];\n        } else if ('Y' === sp_prm[0]) {\n          return [undefined, sp_prm.substring(2, sp_prm.length - 1), undefined];\n        } else if ('Z' === sp_prm[0]) {\n          return [undefined, undefined, sp_prm.substring(2, sp_prm.length - 1)];\n        }\n\n        let ret = gprm.substring(\"translate\".length - 1, gprm.length - 1).split(',');\n        ret.push(undefined);\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    };\n\n    let trans = prm.style(\"transform\");\n\n    if (null === trans) {\n      set(x, y, z);\n      return;\n    }\n\n    let trans_val = get(trans);\n    /* set translate */\n\n    set(undefined !== x ? x : trans_val[0], undefined !== y ? y : trans_val[1], undefined !== z ? z : trans_val[2]);\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-util-transform/index.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Base.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/core/Base.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Base.js\n * @brief basement class of mofron\n * @author simpart\n */\nconst comutl = mofron.util.common;\n\nconst ConfManager = __webpack_require__(/*! ./ConfManager.js */ \"./node_modules/mofron/src/core/ConfManager.js\");\n\nlet genid = () => {\n  try {\n    let ret_id = '_' + new Date().getTime() + '-';\n    let loop = 0;\n    let val = 0;\n\n    for (loop = 0; loop < 8; loop++) {\n      val = Math.random() * 16 | 0;\n      ret_id += (loop == 12 ? 4 : loop == 16 ? val & 3 | 8 : val).toString(16);\n    }\n\n    return ret_id;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = class {\n  constructor() {\n    try {\n      this.m_confmng = new ConfManager();\n      /* init config */\n\n      this.confmng().add(\"name\", {\n        type: \"string\",\n        private: true\n      });\n      this.confmng().add(\"modname\", {\n        type: \"string\",\n        private: true,\n        list: true\n      });\n      this.confmng().add(\"id\", {\n        type: \"string\",\n        private: true,\n        init: genid()\n      });\n      this.confmng().add(\"data\", {\n        type: \"key-value\",\n        private: true\n      });\n      this.confmng().add(\"shortForm\", {\n        type: \"array\",\n        private: true,\n        init: []\n      });\n      this.modname(\"Base\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * config manager\n   * \n   * @param (string) config key\n   * @param (mixed) config data\n   * @param (mixed) config option\n   * @return (mixed) config data\n   */\n\n\n  confmng(key, val, opt) {\n    try {\n      return undefined === key ? this.m_confmng : this.m_confmng.conf(key, val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * object name setter/getter\n   * \n   * @param (string) object name\n   * @return (string) object name\n   */\n\n\n  name(key) {\n    try {\n      if (undefined !== key) {\n        mofron.objkey[key] = this;\n      }\n\n      return this.confmng(\"name\", key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * module name setter / getter\n   *\n   * @param (string) module name\n   * @return (string) module name\n   */\n\n\n  modname(prm) {\n    try {\n      let ret = this.confmng(\"modname\", prm);\n      return undefined !== ret ? ret[ret.length - 1] : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * module id getter\n   * \n   * @return (string) module id\n   */\n\n\n  id() {\n    try {\n      return this.confmng().get(\"id\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * data buffer\n   * \n   * @param (string) buffer key\n   * @param (mixed) buffer data\n   *                undefined: call as getter\n   * @return (mixed) buffer data\n   */\n\n\n  data(key, val) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let dat = this.confmng().get(\"data\");\n\n      if (undefined === val) {\n        /* getter */\n        return undefined === dat[key] ? null : dat[key];\n      }\n      /* setter */\n\n\n      dat[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * short form parameter setter/getter\n   * \n   * @param (string) \n   */\n\n\n  shortForm() {\n    try {\n      if (0 === arguments.length) {\n        return this.confmng().get(\"shortForm\");\n      }\n\n      let val = [];\n\n      for (let aidx in arguments) {\n        val.push(arguments[aidx]);\n      }\n\n      this.confmng(\"shortForm\", val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * execute config\n   * \n   * @param (mixed) config data\n   * @return (mixed) config list\n   */\n\n\n  config() {\n    try {\n      /* get argument */\n      if (0 === arguments.length) {\n        /* getter */\n        let cnf_ret = this.confmng().get(); //delete cnf_ret.style;\n\n        return cnf_ret;\n      }\n\n      let arg = new mofron.class.ConfArg();\n      arg.param(arguments);\n      /* setter */\n\n      if (1 === arguments.length && comutl.isinc(arguments[0], \"ConfArg\")) {\n        arguments[0].exec(this, this.shortForm());\n      } else if (1 < arg.param().length || !(\"object\" === typeof arguments[0] && false === Array.isArray(arguments[0]) && false === comutl.isinc(arguments[0], \"Base\"))) {\n        /* short form */\n        arg.exec(this, this.shortForm());\n      } else {\n        /* config */\n        for (let cf_idx in arguments[0]) {\n          if (\"function\" !== typeof this[cf_idx]) {\n            console.warn(\"invalid function: \" + cf_idx);\n            continue;\n          }\n\n          if (true !== comutl.isinc(arguments[0][cf_idx], \"ConfArg\")) {\n            this[cf_idx](arguments[0][cf_idx]);\n          } else {\n            arguments[0][cf_idx].exec(this, cf_idx);\n          }\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Base.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/ConfManager.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/ConfManager.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * @file ConfManager.js\n * @brief config manager for mofron modules. it suply accessor functions to object.\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class {\n  constructor() {\n    try {\n      this.m_conf = {};\n      this.m_opt = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  conf(key, val, opt) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      return undefined === val ? this.get(key, opt) : this.set(key, val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  add(key, opt) {\n    try {\n      if (\"object\" !== typeof opt || true === Array.isArray(opt) || true === comutl.isinc(opt, \"Base\")) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      this.m_opt[key] = opt;\n\n      if (\"key-value\" === opt.type) {\n        this.m_conf[key] = {};\n        return;\n      } else if (true === opt.list) {\n        this.m_conf[key] = [];\n        return;\n      }\n\n      if (undefined !== opt.init) {\n        this.set(key, opt.init);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  get(key, opt) {\n    try {\n      if (undefined === key) {\n        /* get all config */\n        let ret = {};\n\n        for (let cidx in this.m_conf) {\n          if (true === this.m_opt[cidx].private) {\n            continue;\n          }\n\n          ret[cidx] = this.m_conf[cidx];\n        }\n\n        return ret;\n      } else if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let pvt = undefined !== this.m_conf[key + \"_private\"] ? true : false;\n\n      if ('object' === typeof opt && undefined !== opt.private) {\n        pvt = opt.private;\n      }\n      /* return config */\n\n\n      let ret = undefined !== this.m_conf[key] ? this.m_conf[key] : null;\n\n      if (null !== ret && true === pvt) {\n        let pvt_ret = this.m_conf[key + \"_private\"];\n\n        if (true === this.m_opt[key].list) {\n          return pvt_ret.concat(ret);\n        } else if (\"key-value\" === this.m_opt[key].type) {\n          Object.assign(ret, pvt_ret);\n        }\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  chkValue(key, val) {\n    try {\n      let opt = this.m_opt[key];\n\n      if (undefined === opt || undefined === opt.type) {\n        throw new Error(\"could not find :\" + key);\n      }\n\n      if (\"color\" === opt.type) {\n        let clr = comutl.getcolor(val);\n        return null === clr ? clr : clr.toString();\n      } else if (\"size\" === opt.type) {\n        comutl.getsize(val);\n        return val;\n      } else if (\"event\" === opt.type) {\n        if (true !== Array.isArray(val) || \"function\" !== typeof val[0]) {\n          throw new Error('invalid parameter');\n        }\n\n        return val;\n      } else if (\"array\" === opt.type) {\n        if (false === Array.isArray(val)) {\n          throw new Error('invalid parameter');\n        }\n      } else if (\"key-value\" === opt.type) {\n        if (\"object\" !== typeof val || true === Array.isArray(val) || true === comutl.isinc(val, \"Base\")) {\n          throw new Error('invalid parameter');\n        }\n      } else if (true === comutl.isinc(val, 'Base')) {\n        if (false === comutl.isinc(val, opt.type)) {\n          throw new Error('invalid parameter');\n        }\n      } else if (opt.type !== typeof val) {\n        throw new Error('invalid parameter');\n      }\n\n      return val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  set(key, val, opt) {\n    try {\n      if (\"string\" !== typeof key || undefined === this.m_opt[key]) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      if (true === this.m_opt[key].list && true === Array.isArray(val) && \"array\" !== this.m_opt[key].type && \"event\" !== this.m_opt[key].type) {\n        for (let vidx in val) {\n          this.set(key, val[vidx], opt);\n        }\n\n        return;\n      }\n\n      let set_val = this.chkValue(key, val);\n      let set_key = key;\n\n      if (undefined !== opt && true === opt.private) {\n        set_key = key + \"_private\";\n\n        if (undefined === this.m_opt[set_key]) {\n          this.m_opt[set_key] = {};\n          /* initialize priavte key */\n\n          for (let opt_idx in this.m_opt[key]) {\n            this.m_opt[set_key][opt_idx] = this.m_opt[key][opt_idx];\n          }\n\n          this.m_opt[set_key].private = true;\n\n          if (undefined !== this.m_opt[set_key].init) {\n            this.m_conf[set_key] = this.m_opt[set_key].init;\n          } else if (true === this.m_opt[set_key].list) {\n            this.m_conf[set_key] = [];\n          } else if (\"key-value\" === this.m_opt[set_key].type) {\n            this.m_conf[set_key] = {};\n          }\n        }\n      }\n\n      if (true === this.m_opt[set_key].list) {\n        this.m_conf[set_key].push(set_val);\n      } else if (\"key-value\" === this.m_opt[set_key].type) {\n        for (let vidx in val) {\n          this.m_conf[set_key][vidx] = val[vidx];\n        }\n      } else {\n        if (true === Array.isArray(this.m_opt[set_key].select)) {\n          let exs = false;\n\n          for (let sidx in this.m_opt[set_key].select) {\n            if (set_val === this.m_opt[set_key].select[sidx]) {\n              exs = true;\n              break;\n            }\n          }\n\n          if (false === exs) {\n            throw new Error(\"invald parameter\");\n          }\n        }\n\n        this.m_conf[set_key] = set_val;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  delete(key) {\n    try {\n      if (\"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      delete this.m_conf[key];\n      this.add(key, this.m_opt[key]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ConfManager.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Document.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/core/Document.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Window.js\n * @brief mofron window class\n */\nconst Base = __webpack_require__(/*! ./Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nconst comutl = __webpack_require__(/*! ./../util/common.js */ \"./node_modules/mofron/src/util/common.js\");\n\nmodule.exports = class extends Base {\n  constructor() {\n    try {\n      super();\n      this.modname('Document');\n      this.confmng().add(\"event\", {\n        type: \"Event\",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  getRawDom() {\n    return document;\n  }\n\n  event(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return this.confmng(\"event\");\n      }\n      /* setter */\n\n\n      this.confmng(\"event\", prm); //prm.component(this);\n\n      prm.contents(this);\n      prm.isInited(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Document.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/ModConf.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/ModConf.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file ModConf.js\n * @brief module config interface for mofron component\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ./Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nmodule.exports = class extends Base {\n  constructor(po) {\n    try {\n      super(po);\n      this.modname('ModConf');\n      /* init config */\n\n      this.confmng().add(\"component\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"tag\", {\n        type: \"string\"\n      });\n      this.confmng().add(\"isInited\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"suspend\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.confmng().add(\"innerTgt\", {\n        type: \"boolean\",\n        init: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  component(prm) {\n    try {\n      return this.confmng(\"component\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  execute() {\n    console.warn('not implement');\n  }\n\n  contents(p1) {\n    console.warn('not implement');\n  }\n\n  tag(prm) {\n    try {\n      return this.confmng(\"tag\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isInited(prm) {\n    try {\n      return this.confmng(\"isInited\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  suspend(prm) {\n    try {\n      return this.confmng(\"suspend\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  innerTgt(prm) {\n    try {\n      return this.confmng(\"innerTgt\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ModConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/Window.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/core/Window.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Window.js\n * @brief mofron window class\n */\n//const Base   = require(\"./Base.js\");\n//const Component = require(\"../tag/Component.js\");\nconst comutl = __webpack_require__(/*! ./../util/common.js */ \"./node_modules/mofron/src/util/common.js\");\n\nmodule.exports = class extends mofron.class.Component {\n  constructor() {\n    try {\n      super();\n      this.modname('Window');\n      this.confmng().add(\"landscapeEvent\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"portraitEvent\", {\n        type: \"event\",\n        list: true\n      }); //this.confmng().add(\"event\", { type: \"Event\", list: true });\n\n      this.initOrientation();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isPortrait() {\n    try {\n      return window.innerHeight > window.innerWidth ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isLandscape() {\n    try {\n      return window.innerHeight < window.innerWidth ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  resizeEvent(func, prm, tlag) {\n    try {\n      let que_buf = null;\n      let param = prm;\n      let time_lag = undefined === tlag ? 200 : tlag;\n\n      if ('function' !== typeof func || 'number' !== typeof time_lag) {\n        throw new Error('invalid parameter');\n      }\n\n      window.addEventListener('resize', () => {\n        try {\n          clearTimeout(que_buf);\n          que_buf = setTimeout(func, time_lag, param);\n        } catch (e) {\n          console.error(e.stack);\n          throw new Error();\n        }\n      }, false);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  initOrientation() {\n    try {\n      if (undefined !== screen.orientation && null === screen.orientation.onchange) {\n        screen.orientation.onchange = this.orientationHandler;\n      } else if (null === screen.onmozorientationchange) {\n        screen.onmozorientationchange = this.orientationHandler;\n      } else if (null === screen.onmsorientationchange) {\n        screen.onmsorientationchange = this.orientationHandler;\n      } else {\n        window.addEventListener(\"orientationchange\", this.orientationHandler);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  orientationHandler(evt) {\n    try {\n      let ef = null;\n\n      if (\"landscape-primary\" === screen.mozOrientation || \"landscape-secondary\" === screen.mozOrientation || \"landscape-primary\" === screen.orientation.type || \"landscape-secondary\" === screen.orientation.type) {\n        /* landscape event */\n        if (\"function\" === typeof this[\"landscapeEvent\"]) {\n          ef = this.landscapeEvent();\n        }\n      } else if (\"portrait-primary\" === screen.mozOrientation || \"portrait-secondary\" === screen.mozOrientation || \"portrait-primary\" === screen.orientation.type || \"portrait-secondary\" === screen.orientation.type) {\n        /* vertical event */\n        if (\"function\" === typeof this[\"portraitEvent\"]) {\n          ef = this.portraitEvent();\n        }\n      } else {\n        if (window.innerHeight < window.innerWidth) {\n          /* landscape event */\n          if (\"function\" === typeof this[\"landscapeEvent\"]) {\n            ef = this.landscapeEvent();\n          }\n        } else {\n          /* portrait event */\n          if (\"function\" === typeof this[\"portraitEvent\"]) {\n            ef = this.portraitEvent();\n          }\n        }\n      }\n\n      for (let eidx in ef) {\n        ef[eidx].exec(this, evt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  landscapeEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        return this.confmng(\"landscapeEvent\");\n      }\n\n      this.confmng(\"landscapeEvent\", [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  portraitEvent(fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        return this.confmng(\"portraitEvent\");\n      }\n\n      this.confmng(\"portraitEvent\", [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  eventDom() {\n    return this;\n  }\n\n  getRawDom() {\n    return window;\n  }\n\n  event(prm) {\n    try {\n      let ret = super.event(prm);\n\n      if (undefined === prm) {\n        return ret;\n      }\n\n      if (true === comutl.isinc(prm, \"Event\")) {\n        prm.execute();\n      } else if (true === Array.isArray(prm)) {\n        for (let pidx in prm) {\n          prm[pidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Window.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Attrs.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Attrs.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Attrs.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\n\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Attrs');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().setAttribute(key, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domRem(key) {\n    try {\n      this.dom().getRawDom().removeAttribute(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get attribute value from rawdom\n   *\n   * @param key : (string) style key\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n\n\n  domGet(key) {\n    try {\n      return this.dom().getRawDom().getAttribute(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n\n      for (let cidx in conts) {\n        ret += null === conts[cidx] ? cidx : cidx + '=\"' + conts[cidx] + '\"';\n        ret += \" \";\n      }\n\n      return \"\" === ret ? \"\" : ret.substring(0, ret.length - 1);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Attrs.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Class.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Class.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Class.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\n\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Class');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  set(prm, opt) {\n    try {\n      if (!(\"string\" === typeof prm || true === Array.isArray(prm))) {\n        throw new Error('invalid parameter');\n      }\n\n      let set_prm = {};\n\n      if (\"string\" === typeof prm) {\n        set_prm[prm] = \"\";\n      } else {\n        for (let pidx in prm) {\n          if (\"string\" !== typeof prm[pidx]) {\n            throw new Error(\"invalid parameter\");\n          }\n\n          set_prm[prm[pidx]] = \"\";\n        }\n      }\n\n      super.set(set_prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  get() {\n    try {\n      let ret = [];\n      let cls = super.get();\n\n      for (let cidx in cls) {\n        ret.push(cidx);\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set class name to rowdom\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().classList.add(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domRem(key) {\n    try {\n      this.dom().getRawDom().classList.remove(key);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get class name from rawdom\n   *\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n\n\n  domGet() {\n    try {\n      let clnm = this.dom().getRawDom().className;\n\n      if (undefined === clnm || null === clnm || '' === clnm) {\n        return null;\n      }\n\n      return clnm.split(' ');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n\n      for (let idx in conts) {\n        ret += conts[idx] + \" \";\n      }\n\n      return '' === ret ? '' : 'class=\"' + ret.substring(0, ret.length - 1) + '\"';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Class.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Dom.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Dom.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Dom.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nconst Class = __webpack_require__(/*! ./Class.js */ \"./node_modules/mofron/src/core/dom/Class.js\");\n\nconst Style = __webpack_require__(/*! ./Style.js */ \"./node_modules/mofron/src/core/dom/Style.js\");\n\nconst Attrs = __webpack_require__(/*! ./Attrs.js */ \"./node_modules/mofron/src/core/dom/Attrs.js\");\n\nconst Props = __webpack_require__(/*! ./Props.js */ \"./node_modules/mofron/src/core/dom/Props.js\");\n\nconst Tree = __webpack_require__(/*! ../tree/Tree.js */ \"./node_modules/mofron/src/core/tree/Tree.js\");\n\nconst IDX_CLASS = 0;\nconst IDX_STYLE = 1;\nconst IDX_ATTRS = 2;\nconst IDX_PROPS = 3;\nmodule.exports = class extends Base {\n  /**\n   * initialize member\n   *\n   */\n  constructor(tc, cmp) {\n    try {\n      super();\n      this.modname('Dom');\n      this.confmng().add(\"tag\", {\n        type: \"string\"\n      });\n      this.confmng().add(\"component\", {\n        type: \"Component\"\n      });\n      this.confmng().add(\"text\", {\n        type: \"string\",\n        init: \"\"\n      });\n      this.confmng().add(\"dummy\", {\n        type: \"boolean\",\n        init: false\n      });\n      this.m_tree = new Tree(this);\n      this.m_rawdom = null;\n      this.m_conf = [new Class(this), new Style(this), new Attrs(this), new Props(this)];\n\n      if (\"string\" === typeof tc) {\n        this.tag(tc);\n        this.component(cmp);\n      } else if (undefined !== tc) {\n        this.config(tc);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * tag name setter / getter\n   *\n   * @param tg : (string) tag name (option)\n   * @return (string) tag name\n   */\n\n\n  tag(tg) {\n    try {\n      return this.confmng(\"tag\", tg);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * component getter / setter\n   * \n   * @param cmp (object) mofron.Component\n   * @return (object) mofron.Component\n   */\n\n\n  component(cmp) {\n    try {\n      return this.confmng(\"component\", cmp);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  getTree() {\n    try {\n      return this.m_tree;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  child(chd, idx) {\n    try {\n      if (undefined === chd) {\n        /* getter */\n        return this.m_tree.getChild();\n      }\n      /* setter */\n\n\n      this.m_tree.addChild(chd, idx);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  parent(prm) {\n    try {\n      return this.m_tree.parent(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  conf(kv, opt, idx) {\n    try {\n      let cnf = this.m_conf[idx];\n\n      if (undefined === kv) {\n        /* get style object */\n        return cnf;\n      } else if ('string' === typeof kv) {\n        /* get style value of the key */\n        return cnf.get(kv);\n      }\n      /* setter */\n\n\n      cnf.set(kv, opt);\n      this.value(null);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * style setter / getter\n   *\n   * @param kv : (object) key-value object\n   * @param opt: (object) option\n   * @return (string) : value of style\n   * @return (object) : style object\n   */\n\n\n  style(kv, opt) {\n    try {\n      if (undefined !== opt && true === opt.bpref) {\n        for (let key in kv) {\n          kv[\"webkit-\" + key] = kv[key];\n          kv[\"-moz-\" + key] = kv[key];\n          kv[\"-o-\" + key] = kv[key];\n          kv[\"-ms-\" + key] = kv[key];\n        }\n      }\n\n      return this.conf(kv, opt, IDX_STYLE);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * tag attribute setter / getter\n   *\n   * @param kv  : (object/string) key-value object / key of attribute\n   * @param val : (object) value of attribute\n   * @return\n   */\n\n\n  attrs(kv, opt) {\n    try {\n      return this.conf(kv, opt, IDX_ATTRS);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dom property setter / getter\n   * \n   * @param kv  : (object/string) key-value object / key of\n   * @param val : (object)  value of property\n   */\n\n\n  props(kv, opt) {\n    try {\n      return this.conf(kv, opt, IDX_PROPS);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * tag class name setter / getter\n   * \n   * @param name : (string) class name\n   */\n\n\n  class(prm, opt) {\n    try {\n      if (undefined === prm) {\n        return this.conf(undefined === opt ? undefined : \"class\", opt, IDX_CLASS);\n      }\n\n      this.conf(\"string\" === typeof prm ? [prm] : prm, opt, IDX_CLASS);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * tag contents text setter / getter\n   * \n   * @param cnt : (string) tag contents (option)\n   * @return (string) tag contents\n   */\n\n\n  text(prm) {\n    try {\n      let ret = this.confmng(\"text\", prm);\n\n      if (undefined !== prm && true === this.isPushed()) {\n        this.getRawDom().innerHTML = prm;\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dom string getter\n   *\n   * @return (string) dom string\n   */\n\n\n  value() {\n    try {\n      let chd = this.child();\n      let chd_ret = '';\n\n      for (let cidx in chd) {\n        chd_ret += chd[cidx].value();\n      }\n\n      if (true === this.dummy()) {\n        return chd_ret;\n      }\n\n      let ret = '<' + this.tag() + ' ';\n      /* set id attribute */\n\n      ret += 'id=\"' + this.id() + '\" ';\n      /* set dom config */\n\n      let cnf = this.m_conf;\n      let cnf_val = null;\n\n      for (var idx in cnf) {\n        let cnf_val = cnf[idx].toString();\n\n        if (\"\" !== cnf_val) {\n          ret += cnf_val + \" \";\n        }\n      }\n\n      ret += '>';\n      /* set tag contents */\n\n      ret += this.text();\n      /* check single */\n\n      if (true === is_single(this.tag())) {\n        return ret;\n      }\n      /* set child value */\n\n\n      ret += chd_ret;\n      return ret + '</' + this.tag() + '>';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * draw dom to target dom\n   * \n   * @param (key-value) push option\n   *     target   : push target object\n   *     child    : child flag\n   *     position : position of insertAdjacentHTML parameter\n   */\n\n\n  push(opt) {\n    try {\n      if (true === mofron.ssr) {\n        return;\n      } else if (undefined === opt) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      if (true !== opt.child) {\n        opt.target.insertAdjacentHTML(undefined === opt.position ? 'beforeend' : opt.position, this.value());\n      }\n\n      let props = this.props().get();\n\n      if (true === this.dummy()) {\n        this.m_rawdom = null !== this.parent() ? this.parent().getRawDom() : null;\n      } else {\n        if (null !== this.parent()) {\n          this.m_rawdom = this.parent().getRawDom().querySelector(\"#\" + this.id());\n        } else {\n          this.m_rawdom = document.body.querySelector(\"#\" + this.id());\n        }\n      }\n\n      this.props(props); // set property\n\n      /* notify push to children */\n\n      let chd = this.child();\n\n      for (let cidx in chd) {\n        chd[cidx].push({\n          target: this.m_rawdom,\n          child: true\n        });\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get adom status\n   *\n   * @return (boolean) true : this adom had pushed\n   * @return (boolean) false : this adom had not pushed\n   */\n\n\n  isPushed() {\n    try {\n      return null === this.m_rawdom ? false : true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get pushed dom object from blowser\n   *\n   * @return (object) raw dom object\n   */\n\n\n  getRawDom() {\n    try {\n      if (false === this.isPushed()) {\n        throw new Error('this dom is not pushed yet');\n      }\n\n      return this.m_rawdom;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  destroy() {\n    try {\n      /* remove this object from parent dom */\n      if (true === this.isPushed()) {\n        this.getRawDom().remove();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  dummy(prm) {\n    try {\n      return this.confmng(\"dummy\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n\nlet is_single = prm => {\n  try {\n    if (\"br\" === prm || \"hr\" === prm || \"input\" === prm || \"img\" === prm) {\n      return true;\n    }\n\n    return false;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Dom.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/DomConf.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/DomConf.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file DomConf.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends Base {\n  constructor(dom) {\n    try {\n      super();\n      this.modname(\"DomConf\");\n      this.confmng().add(\"lock\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"dom\", {\n        type: \"Dom\"\n      });\n      this.confmng().add(\"listener\", {\n        type: \"array\",\n        list: true\n      });\n      this.dom(dom);\n      this.m_conts = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  dom(prm) {\n    try {\n      return this.confmng(\"dom\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  lock(key, val) {\n    try {\n      let lock = this.confmng().get(\"lock\");\n\n      if (undefined === val) {\n        /* getter */\n        return undefined === lock[key] ? false : lock[key];\n      }\n      /* setter */\n\n\n      if (\"boolean\" !== typeof val) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      lock[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  chkval(kv) {\n    try {\n      if (!(\"object\" === typeof kv && false === Array.isArray(kv) && false === comutl.isinc(kv, \"Base\"))) {\n        throw new Error('invalid parameter');\n      }\n\n      for (let key in kv) {\n        if (null !== kv[key] && \"object\" === typeof kv[key]) {\n          throw new Error(\"invalid parameter\");\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  set(kv, opt) {\n    try {\n      this.chkval(kv);\n      let p_opt = undefined === opt ? {} : opt;\n      let lis = [];\n\n      for (let key in kv) {\n        let old_kv = {};\n        let new_kv = {};\n        old_kv[key] = undefined === this.m_conts[key] ? null : this.m_conts[key];\n        new_kv[key] = kv[key];\n\n        if (null === kv[key]) {\n          /* delete config */\n          this.rem(key);\n          lis = this.listener(key);\n\n          for (let lidx in lis) {\n            lis[lidx][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx][1]);\n          }\n\n          if (true === p_opt.lock) {\n            this.lock(key, true);\n          }\n\n          continue;\n        }\n        /* setter */\n\n\n        if (true === p_opt.passive) {\n          if (null === this.get(key)) {\n            this.m_conts[key] = kv[key];\n          } else {\n            continue;\n          }\n        } else if (true === p_opt.forced) {\n          this.m_conts[key] = kv[key];\n          this.lock(key, false);\n        } else {\n          if (true === this.lock(key)) {\n            continue;\n          }\n\n          this.m_conts[key] = kv[key];\n        }\n\n        if (true === p_opt.lock) {\n          this.lock(key, true);\n        }\n\n        if (true === this.dom().isPushed()) {\n          /* target dom is already rendered */\n          this.domSet(key, kv[key]);\n        }\n\n        lis = this.listener(key);\n\n        for (let lidx2 in lis) {\n          lis[lidx2][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx2][1]);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  get(key) {\n    try {\n      if (false === this.dom().isPushed()) {\n        if (undefined === key) {\n          return this.m_conts;\n        }\n\n        return undefined === this.m_conts[key] ? null : this.m_conts[key];\n      } else {\n        /* target is already rendered */\n        return undefined == this.domGet(key) ? null : this.domGet(key);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  rem(key) {\n    try {\n      if (undefined !== this.m_conts[key]) {\n        delete this.m_conts[key];\n      }\n\n      if (true === this.dom().isPushed()) {\n        /* target dom is already rendered */\n        this.domRem(key);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domRem(key) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domSet(key, val) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domGet(key) {\n    try {\n      console.warn('not implement');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  listener(key, fnc, prm) {\n    try {\n      if (undefined === fnc) {\n        /* getter */\n        let lis = this.confmng(\"listener\");\n\n        if (undefined === key) {\n          return lis;\n        }\n\n        let ret = [];\n\n        for (let lidx in lis) {\n          if (key === lis[lidx][0]) {\n            ret.push([lis[lidx][1], lis[lidx][2]]);\n          }\n        }\n\n        return ret;\n      }\n\n      if (\"string\" !== typeof key || \"function\" !== typeof fnc) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      this.confmng(\"listener\", [key, fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/DomConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Props.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Props.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Props.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target dom object\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Prop');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  chkval(kv) {\n    try {\n      if (!(\"object\" === typeof kv && false === Array.isArray(kv) && false === comutl.isinc(kv, \"Base\"))) {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set property\n   *\n   * @param key : (string) property key\n   * @param val : (string) property value\n   */\n\n\n  domSet(key, val) {\n    try {\n      if (undefined === this.dom().getRawDom()[key]) {\n        throw new Error(key + ' is unknown property');\n      }\n\n      this.dom().getRawDom()[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domRem(key) {\n    try {\n      if (undefined === this.dom().getRawDom()[key]) {\n        return;\n      }\n\n      delete this.dom().getRawDom()[key];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get property value from rawdom\n   *\n   * @param key : (string) property key\n   * @return (string) property value\n   */\n\n\n  domGet(key) {\n    try {\n      let ret = this.dom().getRawDom()[key];\n      return \"\" === ret ? undefined : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toString() {\n    try {\n      return \"\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Props.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/dom/Style.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Style.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Style.js\n * @author simpart\n */\nconst DomConf = __webpack_require__(/*! ./DomConf.js */ \"./node_modules/mofron/src/core/dom/DomConf.js\");\n\nmodule.exports = class extends DomConf {\n  /**\n   * initialize member\n   *\n   */\n  constructor(tgt) {\n    try {\n      super(tgt);\n      this.modname('Style');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  domSet(key, val) {\n    try {\n      this.dom().getRawDom().style[getcamel(key)] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get style value from rawdom\n   *\n   * @param key : (string) style key\n   * @return (object) style contents\n   * @return (string) style contents value\n   */\n\n\n  domGet(key) {\n    try {\n      if (undefined === key) {\n        return this.dom().getRawDom().style;\n      }\n\n      let val = this.dom().getRawDom().style[getcamel(key)];\n      return undefined === val || \"\" === val ? null : val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  domRem(key) {\n    try {\n      this.dom().getRawDom().style[getcamel(key)] = \"\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toString() {\n    try {\n      let ret = '';\n      let conts = this.get();\n\n      for (let cidx in conts) {\n        ret += cidx + ':' + conts[cidx] + ';';\n      }\n\n      return '' === ret ? '' : 'style=\"' + ret + '\"';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n\nlet getcamel = prm => {\n  try {\n    if ('string' !== typeof prm) {\n      throw new Error('invalid parameter');\n    }\n\n    if (prm.length - 1 === prm.lastIndexOf('-')) {\n      throw new Error('invalid parameter');\n    }\n\n    var skip = false;\n\n    if (0 === prm.indexOf('-')) {\n      skip = true;\n    }\n\n    var ret_val = prm;\n    var ret_buf = null;\n    var up_str = null;\n    var idx = null;\n\n    while (true) {\n      idx = ret_val.indexOf('-');\n\n      if (-1 === idx) {\n        break;\n      }\n\n      up_str = ret_val.charAt(idx + 1).toUpperCase();\n      ret_buf = ret_val.substr(0, idx);\n\n      if (true === skip) {\n        skip = false;\n        ret_val = ret_buf + ret_val.substr(idx + 1);\n      } else {\n        ret_val = ret_buf + up_str + ret_val.substr(idx + 2);\n      }\n    }\n\n    return ret_val;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Style.js?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js ***!
  \******************************************************************************************************************/
/***/ ((module) => {

eval("/**\n * @file namespace.js\n * @author simpart\n */\n//const Window = require(\"./Window.js\");\nmodule.exports = {\n  root: [],\n  window: null,\n  class: {},\n  objkey: {},\n  util: {} //debug  : false\n\n};\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js?./node_modules/babel-loader/lib/index.js??ruleSet%5B1%5D.rules%5B0%5D.use");

/***/ }),

/***/ "./node_modules/mofron/src/core/tree/CompTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/CompTree.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file CompTree.js\n * @brief tree manager for component\n * @license MIT\n */\nconst Tree = __webpack_require__(/*! ./Tree.js */ \"./node_modules/mofron/src/core/tree/Tree.js\");\n\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\nmodule.exports = class extends Tree {\n  addChild(chd, idx) {\n    try {\n      if (true === Array.isArray(chd)) {\n        /* parameter check */\n        for (let cidx in chd) {\n          this.addChild(chd[cidx], idx);\n        }\n\n        return;\n      }\n      /* set parent-child relation in dom layer */\n\n\n      let rdom = chd.rootDom();\n\n      if (undefined === idx) {\n        this.target().childDom().child(rdom);\n      } else {\n        let tgt_tree = this.target().childDom().getTree();\n        let t_idx = tgt_tree.getIndex(this.target().child()[idx].rootDom()[0]);\n        tgt_tree.addChild(rdom, t_idx);\n      }\n      /* set parent-child relation in component layer */\n\n\n      super.addChild(chd, idx);\n      /* check render */\n\n      if (true === this.target().isExists()) {\n        let layout = chd.layout();\n        /* layout */\n\n        for (var lidx in layout) {\n          lo[lo_idx].execute();\n        }\n        /* theme */\n\n\n        cmputl.theme(chd, this.target().theme());\n        /* render child */\n\n        cmputl.render(chd);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  replace(o_chd, n_chd) {\n    try {\n      if (this.target().childDom().id() === o_chd.childDom().id()) {\n        /* old child is dom target, replace dom target */\n        this.target().childDom(n_chd.childDom());\n      }\n      /* set parent-child relation in component layer */\n\n\n      this.getChild().splice(this.getIndex(o_chd), 0, n_chd);\n      n_chd.parent(this.target());\n      /* set parent-child relation in dom layer */\n\n      let tgt_tree = o_chd.rootDom()[0].parent().getTree();\n      let rep_idx = tgt_tree.getIndex(o_chd.rootDom()[0]);\n      let n_rdom = n_chd.rootDom();\n\n      for (let ridx in n_rdom) {\n        tgt_tree.getChild().splice(rep_idx + parseInt(ridx), 0, n_rdom[ridx]);\n        n_rdom[ridx].parent(this.target().childDom());\n      }\n\n      if (true === o_chd.isExists()) {\n        cmputl.render(n_chd);\n      }\n\n      o_chd.destroy();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  delChild(chd) {\n    try {\n      /* release relational in dom layer */\n      let rdom = chd.rootDom();\n\n      for (let ridx in rdom) {\n        if (null !== rdom[ridx].parent()) {\n          rdom[ridx].parent().getTree().delChild(rdom[ridx]);\n        }\n      }\n      /* delete child component */\n\n\n      super.delChild(chd);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/CompTree.js?");

/***/ }),

/***/ "./node_modules/mofron/src/core/tree/Tree.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/Tree.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file Tree.js\n * @brief basement tree manager\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmodule.exports = class {\n  constructor(tgt, elm) {\n    try {\n      this.m_parent = null;\n      this.m_child = [];\n      this.elemName(tgt.modname());\n      this.target(tgt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  elemName(prm) {\n    try {\n      if (undefined === prm) {\n        if (undefined === this.m_elemnm) {\n          throw new Error(\"could not find element name\");\n        }\n\n        return this.m_elemnm;\n      }\n\n      if (\"string\" !== typeof prm) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      this.m_elemnm = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  target(prm) {\n    try {\n      if (undefined === prm) {\n        if (undefined === this.m_target) {\n          throw new Error(\"could not find target\");\n        }\n\n        return this.m_target;\n      }\n\n      if (false === comutl.isinc(prm, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n\n      this.m_target = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  getChild() {\n    try {\n      return this.m_child;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  addChild(chd, idx) {\n    try {\n      /* parameter check */\n      if (true === Array.isArray(chd)) {\n        for (let cidx in chd) {\n          this.addChild(chd[cidx], undefined !== idx ? idx + parseInt(cidx) : undefined);\n        }\n\n        return;\n      }\n\n      if (false === comutl.isinc(chd, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n      /* set parent-child relation */\n\n\n      chd.parent(this.target());\n      /* add child */\n\n      if (undefined === idx) {\n        this.getChild().push(chd);\n      } else {\n        this.getChild().splice(idx, 0, chd);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  delChild(chd) {\n    try {\n      let del_idx = this.getIndex(chd);\n      this.getChild().splice(del_idx, 1);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  parent(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        return undefined === this.m_parent ? null : this.m_parent;\n      }\n\n      if (false === comutl.isinc(prm, this.elemName())) {\n        throw new Error('invalid parameter');\n      }\n\n      this.m_parent = prm;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  getIndex(prm) {\n    try {\n      let chd = this.getChild();\n\n      for (let cidx in chd) {\n        if (chd[cidx].id() === prm.id()) {\n          return parseInt(cidx);\n        }\n      }\n\n      throw new Error(\"invalid parameter\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/Tree.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Component.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/tag/Component.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file   Component.js\n * @brief  basement component class\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nconst CompTree = __webpack_require__(/*! ../core/tree/CompTree.js */ \"./node_modules/mofron/src/core/tree/CompTree.js\");\n\nconst Dom = mofron.class.Dom;\nconst comutl = mofron.util.common;\nconst cmputl = mofron.util.component;\n\nconst effutl = __webpack_require__(/*! ../util/effect.js */ \"./node_modules/mofron/src/util/effect.js\");\n\nmodule.exports = class extends Base {\n  /**\n   * initialize property, dom\n   *\n   * @param (mixed) component proterty\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname(\"Component\");\n      this.confmng().add(\"rootDom\", {\n        type: \"Dom\",\n        list: true,\n        private: true\n      });\n      this.confmng().add(\"childDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"styleDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"eventDom\", {\n        type: \"Dom\",\n        private: true\n      });\n      this.confmng().add(\"layout\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"effect\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"event\", {\n        type: \"ModConf\",\n        list: true\n      });\n      this.confmng().add(\"style\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"theme\", {\n        type: \"key-value\"\n      });\n      this.confmng().add(\"innerComp\", {\n        type: \"key-value\",\n        private: true\n      });\n      this.confmng().add(\"mainColor\", {\n        type: \"color\"\n      });\n      this.confmng().add(\"baseColor\", {\n        type: \"color\"\n      });\n      this.confmng().add(\"accentColor\", {\n        type: \"color\"\n      });\n      /* initialize member */\n\n      this.m_tree = new CompTree(this);\n      /*** set config ***/\n\n      this.shortForm(\"child\");\n      /* user config */\n\n      if (undefined !== prm) {\n        this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /*** dom method ***/\n\n  /**\n   * dom setter / getter\n   * \n   * @return (object) dom object\n   */\n\n\n  rootDom(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        if (0 === this.confmng().get(\"rootDom\").length) {\n          this.initDomConts();\n        }\n\n        return this.confmng().get(\"rootDom\");\n      }\n      /* setter */\n\n\n      this.confmng().set(\"rootDom\", prm);\n\n      if (null === this.childDom()) {\n        this.childDom(this.rootDom()[0]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * dom target setter / getter\n   * \n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n\n\n  childDom(tgt) {\n    try {\n      let ret = this.confmng(\"childDom\", tgt);\n\n      if (null === ret) {\n        if (0 < this.rootDom().length) {\n          this.confmng(\"childDom\", this.rootDom()[0]);\n          return this.confmng(\"childDom\");\n        } else {\n          throw new Error(\"could not find child dom\");\n        }\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get style target dom\n   *\n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n\n\n  styleDom(tgt) {\n    try {\n      let ret = this.confmng(\"styleDom\", tgt);\n      return null === ret ? this.childDom() : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get event target dom\n   *\n   * @param tgt : (object) dom object\n   * @return (object) dom object\n   */\n\n\n  eventDom(tgt) {\n    try {\n      let ret = this.confmng(\"eventDom\", tgt);\n      return null === ret ? this.childDom() : ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  beforeRender() {\n    try {\n      cmputl.chdloop(this, \"beforeRender\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  initDomConts(prm) {\n    try {\n      this.rootDom(new Dom(undefined === prm ? \"div\" : prm, this));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  afterRender() {\n    try {\n      cmputl.chdloop(this, \"afterRender\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  getTree() {\n    try {\n      return this.m_tree;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /*** child method ***/\n\n  /**\n   * child component setter / getter\n   * \n   * @param chd : (object) child component\n   * @param chd : (object) child component array\n   * @return (array) : childlen object\n   */\n\n\n  child(chd, idx) {\n    try {\n      this.rootDom();\n      let ct = true === cmputl.isinncmp(this) ? this.childDom().component().getTree() : this.getTree();\n\n      if (undefined === chd) {\n        /* getter */\n        return ct.getChild();\n      }\n      /* setter */\n\n\n      ct.addChild(chd, idx);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  parent(prm) {\n    try {\n      return this.getTree().parent(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  innerComp(key, val, defcmp) {\n    try {\n      let incmp = this.confmng().get(\"innerComp\");\n\n      if (undefined === val) {\n        /* getter */\n        if (undefined === incmp[key]) {\n          this[key](new defcmp());\n        }\n\n        return incmp[key];\n      } else if (false === comutl.iscmp(val)) {\n        throw new Error(\"invalid parameter\");\n      }\n      /* setter */\n\n\n      if (undefined !== incmp[key]) {\n        if (false === comutl.isinc(val, incmp[key].modname())) {\n          throw new Error(\"invalid parameter\");\n        }\n        /* rewrite component, replace target child */\n\n\n        let pnt = incmp[key].parent();\n\n        if (null !== pnt) {\n          pnt.getTree().replace(incmp[key], val);\n        }\n      }\n\n      incmp[key] = val;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /* component method */\n\n  /**\n   * execute effect\n   *\n   * @param (number) execute id\n   * @param (function, array) callback\n   * @return (boolean) execute result\n   */\n\n\n  execEffect(eid, cb, cbp) {\n    try {\n      return effutl.exec(cmputl.modconf(this, \"effect\"), eid, [cb, cbp]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isExists() {\n    try {\n      return this.childDom().isPushed();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /*** user config method ***/\n\n  /**\n   * style getter / setter\n   *\n   * @return (object) style object\n   */\n\n\n  style(kv, opt) {\n    try {\n      if (\"string\" === typeof kv) {\n        /* getter */\n        return this.styleDom().style(kv);\n      }\n\n      this.styleDom().style(kv, opt);\n      this.confmng(\"style\", kv, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  layout(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"layout\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  effect(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"effect\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  event(prm, opt) {\n    try {\n      return cmputl.modconf(this, \"event\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  accessConf() {\n    try {\n      let hit = false;\n\n      for (let arg_idx in arguments) {\n        hit = false;\n\n        if (undefined === arguments[arg_idx].access) {\n          if (true !== hit) {\n            /* set default config */\n            this.config(arguments[arg_idx].config);\n          }\n\n          break;\n        }\n        /* check access types */\n\n\n        let orit = arguments[arg_idx].access.orientation;\n\n        if (undefined !== orit) {\n          if ('portrait' === orit && true !== mofron.window.isPortrait() || 'landscape' === orit && true !== mofron.window.isLandscape()) {\n            continue;\n          }\n\n          delete arguments[arg_idx].access.orientation;\n        }\n\n        hit = comutl.chkacc(arguments[arg_idx].access);\n\n        if (true === hit) {\n          this.config(arguments[arg_idx].config);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * \n   */\n\n\n  theme(prm) {\n    try {\n      return this.confmng(\"theme\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  template(tmpl, prm) {\n    try {\n      if ('function' !== typeof tmpl) {\n        throw new Error('invalid parameter');\n      }\n\n      this.child(tmpl(prm));\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  destroy() {\n    try {\n      /* destroy in component layer */\n      if (null === this.parent()) {\n        return;\n      }\n\n      this.parent().getTree().delChild(this);\n      /* destroy in dom layer */\n\n      let rdom = this.rootDom();\n\n      for (let ridx in rdom) {\n        rdom[ridx].destroy();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  size(x, y, opt) {\n    try {\n      if (undefined === x) {\n        /* getter */\n        return [this.width(), this.height()];\n      }\n      /* setter */\n\n\n      this.width(x, opt);\n      this.height(y, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  width(prm, opt) {\n    try {\n      return cmputl.size(this, \"width\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  height(prm, opt) {\n    try {\n      return cmputl.size(this, \"height\", prm, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /*** color method ***/\n\n\n  color(c1, c2, c3) {\n    try {\n      if (undefined === c1) {\n        /* getter */\n        return [this.mainColor(), this.baseColor(), this.accentColor()];\n      }\n\n      let clr_tgt = [\"mainColor\", \"baseColor\", \"accentColor\"];\n\n      for (let cidx in clr_tgt) {\n        if (undefined === arguments[cidx]) {\n          continue;\n        } else if (true === comutl.isinc(arguments[cidx], \"ConfArg\")) {\n          arguments[cidx].exec(this, clr_tgt[cidx]);\n        } else {\n          this[clr_tgt[cidx]](arguments[cidx]);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  mainColor(prm, opt) {\n    /* this is interface */\n    this.confmng(\"mainColor\", prm);\n    return null;\n  }\n\n  baseColor(clr, opt) {\n    try {\n      /* interface */\n      this.confmng(\"baseColor\", clr);\n      return cmputl.color(this, \"background\", clr, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  accentColor(prm, opt) {\n    /* this is interface */\n    this.confmng(\"accentColor\", prm);\n    return null;\n  }\n\n  visible(flg, cbf, cbp) {\n    try {\n      return cmputl.visible(this, flg, cbf, cbp);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  config(p1, p2, p3, p4, p5) {\n    try {\n      this.rootDom();\n\n      if (0 === arguments.length) {\n        return super.config();\n      }\n\n      super.config(p1, p2, p3, p4, p5);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Component.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Effect.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Effect.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file Effect.js\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\n\nconst cmputl = mofron.util.component;\nconst comutl = mofron.util.common;\nconst effutl = mofron.util.effect;\nmodule.exports = class extends ModConf {\n  constructor(po) {\n    try {\n      super();\n      this.modname('Effect');\n      this.confmng().add(\"callback\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"otCallback\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"beforeEvent\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"order\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"eid\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"speed\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"delay\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"timing\", {\n        type: \"string\",\n        init: \"ease\",\n        select: [\"ease\", \"linear\", \"ease-in\", \"ease-out\", \"ease-in-out\"]\n      });\n      this.confmng().add(\"cubic\", {\n        type: \"array\"\n      });\n      this.confmng().add(\"transition\", {\n        type: \"string\",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * execute effect\n   * \n   * @param p2 (function) simple call back\n   */\n\n\n  execute() {\n    try {\n      if (true === this.isSkipped(this.eid(), this.order())) {\n        return;\n      }\n\n      let trans = false;\n\n      if (0 < this.speed() && null === this.component().style(\"transition\")) {\n        /* direct called execute() function  */\n        effutl.transition([this]);\n        trans = true;\n        this.otCallback((ts1, ts2, ts3) => {\n          try {\n            /* release transition */\n            cmputl.rstyle(this.component(), {\n              'transition': null\n            }, {\n              bpref: true\n            });\n            this.component().styleDom().style({\n              'transition': null\n            }, {\n              bpref: true\n            });\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, this);\n      }\n      /* execute effect */\n\n\n      let exec = exe_eff => {\n        try {\n          exe_eff.contents(exe_eff.component());\n          exe_eff.isInited(true);\n          setTimeout(exe_eff.exeCallback, exe_eff.speed() + exe_eff.delay(), exe_eff);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      exec(this);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  fexec() {\n    try {\n      let sus = this.suspend();\n      this.suspend(false);\n      this.execute();\n      this.suspend(sus);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  contents(eid, cmp) {}\n\n  transition(prm) {\n    try {\n      return this.confmng(\"transition\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  beforeEvent(fnc, prm) {\n    try {\n      return this.confmng(\"beforeEvent\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  otCallback(fnc, prm) {\n    try {\n      let ret = this.confmng(\"otCallback\", undefined === fnc ? undefined : [fnc, prm]);\n\n      if (undefined !== ret) {\n        this.confmng().delete(\"otCallback\");\n        return ret;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * @param p1 (array) [function, param, one time flag]\n   */\n\n\n  callback(fnc, prm) {\n    try {\n      return this.confmng(\"callback\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  exeCallback(eff) {\n    try {\n      /* execute callback */\n      let cb = eff.callback();\n\n      for (let cidx1 in cb) {\n        cb[cidx1][0](eff, eff.component(), cb[cidx1][1]);\n      }\n\n      let ocb = eff.otCallback();\n\n      for (let cidx2 in ocb) {\n        ocb[cidx2][0](eff, eff.component(), ocb[cidx2][1]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isSkipped(eid, ord) {\n    try {\n      if (true === this.suspend() || eid !== this.eid() || ord !== this.order()) {\n        return true;\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * execute order number setter/getter\n   *\n   * @param p1 (number) execute order number\n   * @param p1 (undefined) call as getter\n   * @return (number) execute order number\n   */\n\n\n  order(prm) {\n    try {\n      return this.confmng(\"order\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  eid(prm) {\n    try {\n      return this.confmng(\"eid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /*** default execute config ***/\n\n  /**\n   * effect speed setter/getter\n   *\n   * @param p1 (number) effect speed\n   * @param p1 (undefined) call as getter\n   * @return (number) effect speed\n   */\n\n\n  speed(prm) {\n    try {\n      return this.confmng(\"speed\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  delay(prm) {\n    try {\n      return this.confmng(\"delay\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  timing(prm) {\n    try {\n      return this.confmng(\"timing\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  cubicBezier(p1, p2, p3, p4) {\n    try {\n      if (undefined === p1) {\n        return this.confmng(\"cubic\");\n      }\n\n      if (\"number\" !== typeof p1 || \"number\" !== typeof p2 || \"number\" !== typeof p3 || \"number\" !== typeof p4) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      this.confmng(\"cubic\", [p1, p2, p3, p4]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Effect.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Event.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/tag/Event.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file event.js\n * @author simpart\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends ModConf {\n  /**\n   * initialize member\n   *\n   */\n  constructor() {\n    try {\n      super();\n      this.modname('Event');\n      this.shortForm('listener');\n      this.confmng().add(\"listener\", {\n        type: \"event\",\n        list: true\n      });\n      this.confmng().add(\"eid\", {\n        type: \"number\"\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * set function for event listener\n   *\n   * @param fnc : (function) function for event listener\n   * @param prm : (mixed) function parameter (option)\n   */\n\n\n  listener(fnc, prm) {\n    try {\n      return this.confmng(\"listener\", undefined === fnc ? undefined : [fnc, prm]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  execListener(eprm) {\n    try {\n      if (true === this.suspend()) {\n        return;\n      }\n\n      let lis = this.listener();\n      let prm = null;\n\n      for (let lidx in lis) {\n        lis[lidx][0](this.component(), eprm, lis[lidx][1]);\n      }\n      /* execute effect */\n\n\n      if (null !== this.eid()) {\n        this.component().execEffect(this.eid());\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  execute() {\n    try {\n      this.initevt();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  initevt() {\n    try {\n      if (false === this.isInited()) {\n        this.contents(this.component().eventDom());\n        this.isInited(true);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  eid(prm) {\n    try {\n      return this.confmng(\"eid\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Event.js?");

/***/ }),

/***/ "./node_modules/mofron/src/tag/Layout.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Layout.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file layout/Base.js\n * @brief Base class of layout\n */\nconst ModConf = __webpack_require__(/*! ../core/ModConf.js */ \"./node_modules/mofron/src/core/ModConf.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends ModConf {\n  constructor(po) {\n    try {\n      super();\n      this.modname('Layout');\n      this.confmng().add(\"skip\", {\n        type: \"Component\",\n        list: true\n      });\n      this.confmng().add(\"execlog\", {\n        type: \"Component\",\n        list: true\n      }); //this.m_execnt = 0;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  execute() {\n    try {\n      let cmp_chd = this.component().child();\n\n      for (let cidx in cmp_chd) {\n        /* check skip */\n        if (true === this.isSkipped(cmp_chd[cidx])) {\n          continue;\n        }\n\n        if (false === this.isExeced(cmp_chd[cidx])) {\n          /* execute layout contents */\n          this.contents(parseInt(cidx), cmp_chd[cidx]);\n          this.confmng(\"execlog\", cmp_chd[cidx]);\n        }\n      }\n\n      this.isInited(true);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isExeced(cmp) {\n    try {\n      let elog = this.confmng(\"execlog\");\n\n      for (let eidx in elog) {\n        if (elog[eidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  contents(idx, tgt) {\n    console.warn('not implement');\n  }\n\n  skip(prm) {\n    try {\n      return this.confmng(\"skip\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  isSkipped(cmp) {\n    try {\n      let skp = this.skip();\n\n      for (let sidx in skp) {\n        if (skp[sidx].id() === cmp[cidx].id()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Layout.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/type/Color.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Color.js\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nmodule.exports = class extends Base {\n  /**\n   * initialize member\n   *\n   */\n  constructor(prm) {\n    try {\n      super();\n      this.modname('Color');\n      this.m_rgba = [null, null, null, null];\n      /* red, green, blue, alpha */\n\n      if (true === Array.isArray(prm)) {\n        this.rgba(prm[0], prm[1], prm[2], prm[3]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  rgb(r, g, b) {\n    try {\n      let ret = this.rgba(r, g, b);\n      return undefined !== ret ? [ret[0], ret[1], ret[2]] : undefined;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get rgba value\n   * \n   * @return (object) rgba array object\n   *   [0] -> (number) red value\n   *   [1] -> (number) green value\n   *   [2] -> (number) blue value\n   *   [3] -> (number) alpha value\n   */\n\n\n  rgba(red, green, blue, alpha) {\n    try {\n      if (undefined === red) {\n        /* getter */\n        return this.m_rgba;\n      }\n      /* setter */\n\n\n      var _red = red === undefined ? null : red;\n\n      var _green = green === undefined ? null : green;\n\n      var _blue = blue === undefined ? null : blue;\n\n      var _alpha = alpha === undefined ? 1 : alpha;\n\n      if (null === _red && null === _green && null === _blue) {} else if (null !== _red && null !== _green && null !== _blue) {\n        if ('number' !== typeof _red || 'number' !== typeof _green || 'number' !== typeof _blue) {\n          throw new Error('invalid parameter');\n        }\n      } else {\n        throw new Error('invalid parameter');\n      }\n\n      if ('number' !== typeof _alpha) {\n        throw new Error('invalid parameter');\n      }\n\n      this.m_rgba[0] = _red;\n      this.m_rgba[1] = _green;\n      this.m_rgba[2] = _blue;\n      this.m_rgba[3] = _alpha;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * get coloe style value\n   *\n   * @return (string) rgba(x,x,x,x)\n   * @return (string) none\n   * @note return 'none' if rgb is null.\n   */\n\n\n  toString() {\n    try {\n      let rgba = this.rgba();\n      let red = rgba[0];\n      let green = rgba[1];\n      let blue = rgba[2];\n      let alpha = rgba[3];\n\n      if (null === red && null === green && null === blue) {\n        return 'none';\n      }\n\n      return 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/Color.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/ConfArg.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/type/ConfArg.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file ConfArg.js\n * @brief config argument class\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends Base {\n  constructor() {\n    try {\n      super();\n      this.modname(\"ConfArg\");\n      this.param(arguments);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  exec(tgt, fnc) {\n    try {\n      let arg = this.param();\n\n      if (true === Array.isArray(fnc)) {\n        if (1 === fnc.length) {\n          this.exec(tgt, fnc[0]);\n        } else {\n          if (fnc.length < arg.length) {\n            throw new Error(\"mismatched config count\");\n          }\n\n          for (let aidx in arg) {\n            if (\"function\" !== typeof tgt[fnc[aidx]]) {\n              console.warn(\"invalid config: \" + fnc[aidx]);\n              continue;\n            }\n\n            if (true === comutl.isinc(arg[aidx], \"ConfArg\")) {\n              arg[aidx].exec(tgt, fnc[aidx]);\n            } else {\n              tgt[fnc[aidx]](arg[aidx]);\n            }\n          }\n        }\n\n        return;\n      } else if (\"string\" === typeof fnc) {\n        if (\"function\" !== typeof tgt[fnc]) {\n          console.warn(\"invalid config: \" + fnc);\n          return;\n        }\n\n        if (0 === arg.length) {\n          tgt[fnc]();\n        } else if (1 === arg.length) {\n          tgt[fnc](arg[0]);\n        } else if (2 === arg.length) {\n          tgt[fnc](arg[0], arg[1]);\n        } else if (3 === arg.length) {\n          tgt[fnc](arg[0], arg[1], arg[2]);\n        } else if (4 === arg.length) {\n          tgt[fnc](arg[0], arg[1], arg[2], arg[3]);\n        } else {\n          tgt[fnc](arg[0], arg[1], arg[2], arg[3], arg[4]);\n        }\n      } else {\n        throw new Error(\"invalid parameter\");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  param(prm) {\n    try {\n      if (undefined === prm) {\n        /* getter */\n        if (undefined === this.m_param) {\n          throw new Error(\"could not find param\");\n        }\n\n        return this.m_param;\n      }\n      /* setter */\n\n\n      if (\"object\" !== typeof prm) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let arg = [];\n      let hit = false;\n\n      for (let pidx = prm.length; pidx >= 0; pidx--) {\n        if (true === hit) {\n          arg.unshift(prm[pidx]);\n        } else if (undefined !== prm[pidx]) {\n          arg.unshift(prm[pidx]);\n          hit = true;\n        }\n      }\n\n      this.m_param = arg;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  addParam(prm) {\n    try {\n      this.m_param.push(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/ConfArg.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/PullConf.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/PullConf.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file pullConf.js\n * @brief pull type config argument class\n * @author simpart\n */\nconst ConfArg = __webpack_require__(/*! ./ConfArg.js */ \"./node_modules/mofron/src/type/ConfArg.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends ConfArg {\n  constructor(prm) {\n    try {\n      if (!('object' === typeof prm && false === Array.isArray(prm) && false === comutl.isinc(prm, \"Base\"))) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      super(prm);\n      this.modname(\"PullConf\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  exec(tgt, fnc) {\n    try {\n      tgt[fnc]().config(this.param()[0]);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/PullConf.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Pixel.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Pixel.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Pixel.js\n * @brief pixel size data type\n * @author simpart\n */\nconst Size = __webpack_require__(/*! ./Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\n\nmodule.exports = class extends Size {\n  /**\n   *\n   */\n  constructor(prm) {\n    try {\n      super(prm, 'px');\n      this.modname('Pixel');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toPixel() {\n    try {\n      return this.value();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Pixel.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Rem.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Rem.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Rem.js\n * @brief rem size data type\n * @author simpart\n */\nconst Size = __webpack_require__(/*! ./Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\n\nconst comutl = mofron.util.common;\nmodule.exports = class extends Size {\n  /**\n   *\n   */\n  constructor(prm) {\n    try {\n      super(prm, 'rem');\n      this.modname('Rem');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toPixel() {\n    try {\n      /* get html font-size */\n      let h_fsiz = document.documentElement.style[\"fontSize\"];\n\n      if (\"\" === h_fsiz) {\n        h_fsiz = 625; // default size\n      } else {\n        h_fsiz = parseFloat(h_fsiz);\n      }\n      /* get body font-size */\n\n\n      let b_fsiz = document.body.style[\"fontSize\"];\n\n      if (\"\" === b_fsiz) {\n        b_fsiz = \"0.16\"; // default size\n      } else {\n        b_fsiz = parseFloat(b_fsiz);\n      }\n\n      return this.value() * (b_fsiz * h_fsiz);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  calcu(prm, flg) {\n    try {\n      super.calcu(prm, flg);\n\n      if ('px' === this.type()) {\n        this.value(this.px2Rem());\n        this.type('rem');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Rem.js?");

/***/ }),

/***/ "./node_modules/mofron/src/type/size/Size.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Size.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @file  Size.js\n * @brief size data type\n * @author simpart\n */\nconst Base = __webpack_require__(/*! ../../core/Base.js */ \"./node_modules/mofron/src/core/Base.js\");\n/**\n * @class Size\n * @brief Size Defined Class\n */\n\n\nmodule.exports = class extends Base {\n  /**\n   *\n   */\n  constructor(siz, tp) {\n    try {\n      super();\n      this.modname('Size');\n      this.confmng().add(\"type\", {\n        type: \"string\",\n        init: \"\"\n      });\n      this.confmng().add(\"value\", {\n        type: \"number\",\n        init: 0\n      });\n      this.confmng().add(\"option\", {\n        type: \"object\",\n        init: {}\n      });\n\n      if ('number' === typeof siz && 'string' === typeof tp) {\n        this.value(siz);\n        this.type(tp);\n      } else {\n        throw new Error(\"invalid parameter\");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  type(prm) {\n    try {\n      return this.confmng(\"type\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  value(prm) {\n    try {\n      return this.confmng(\"value\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  option(prm) {\n    try {\n      return this.confmng(\"option\", prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toStyle() {\n    try {\n      return [this.toString(), this.option()];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toString() {\n    try {\n      return null === this.type() ? null : this.value() + this.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  toPixel() {\n    try {\n      throw new Error(\"not supported\");\n    } catch (e) {\n      throw e;\n    }\n  }\n\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Size.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/common.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/common.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file common.js\n * @brief common util functions\n */\nmofron.util.common = {\n  isinc: (obj, nm) => {\n    try {\n      /* parameter check */\n      if (null === obj || 'object' !== typeof obj || true === Array.isArray(obj) || \"function\" !== typeof obj.modname || \"function\" !== typeof obj.confmng) {\n        return false;\n      }\n\n      let chk_nm = \"string\" === typeof nm ? [nm] : nm;\n      let chk_idx = 0;\n      let name_lst = obj.confmng(\"modname\");\n\n      for (let idx in name_lst) {\n        if (chk_nm[chk_idx] === name_lst[idx]) {\n          chk_idx++;\n\n          if (chk_nm.length === chk_idx) {\n            return true;\n          }\n\n          continue;\n        }\n\n        if (0 < chk_idx) {\n          break;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  iscmp: obj => {\n    try {\n      return comutl.isinc(obj, \"Component\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isobj: (obj, nm) => {\n    try {\n      return obj.modname() === nm ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcmp: prm => {\n    try {\n      return new mofron.class.Component(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcolor: prm => {\n    try {\n      if (null === prm || undefined === prm) {\n        return null;\n      } else if ('string' === typeof prm) {\n        if ('none' === prm) {\n          return new mofron.class.Color();\n        } else if (0 === prm.indexOf('rgb')) {\n          let rgb_clr = null;\n\n          if (0 === prm.indexOf('rgba(')) {\n            rgb_clr = prm.substring(5);\n          } else if (0 === prm.indexOf('rgb(')) {\n            rgb_clr = prm.substring(4);\n          } else {\n            throw new Error('invalid parameter');\n          }\n\n          rgb_clr = rgb_clr.substring(0, rgb_clr.length - 1);\n          rgb_clr = rgb_clr.split(',');\n\n          if (3 === rgb_clr.length) {\n            return new mofron.class.Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2])]);\n          } else if (4 === rgb_clr.length) {\n            return new mofron.class.Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2]), parseInt(rgb_clr[3])]);\n          } else {\n            throw new Error('invalid parameter');\n          }\n        } else if (0 === prm.indexOf('#')) {\n          /* hex */\n          let hex_clr = prm.substring(1);\n\n          if (6 !== hex_clr.length) {\n            throw new Error('invalid parameter');\n          }\n\n          return new mofron.class.Color([parseInt(hex_clr.substring(0, 2), 16), parseInt(hex_clr.substring(2, 4), 16), parseInt(hex_clr.substring(4, 6), 16)]);\n        } else {\n          /* name */\n          if ('string' !== typeof prm) {\n            throw new Error('invalid parameter');\n          }\n\n          switch (prm) {\n            case 'black':\n              return new mofron.class.Color([0, 0, 0]);\n\n            case 'gray':\n              return new mofron.class.Color([128, 128, 128]);\n\n            case 'silver':\n              return new mofron.class.Color([192, 192, 192]);\n\n            case 'white':\n              return new mofron.class.Color([255, 255, 255]);\n\n            case 'blue':\n              return new mofron.class.Color([0, 0, 255]);\n\n            case 'navy':\n              return new mofron.class.Color([0, 0, 128]);\n\n            case 'teal':\n              return new mofron.class.Color([0, 128, 128]);\n\n            case 'green':\n              return new mofron.class.Color([0, 128, 0]);\n\n            case 'lime':\n              return new mofron.class.Color([0, 255, 0]);\n\n            case 'aqua':\n              return new mofron.class.Color([0, 255, 255]);\n\n            case 'yellow':\n              return new mofron.class.Color([255, 255, 0]);\n\n            case 'red':\n              return new mofron.class.Color([255, 0, 0]);\n\n            case 'fuchsia':\n              return new mofron.class.Color([255, 0, 255]);\n\n            case 'olive':\n              return new mofron.class.Color([128, 128, 0]);\n\n            case 'purple':\n              return new mofron.class.Color([128, 0, 128]);\n\n            case 'maroon':\n              return new mofron.class.Color([128, 0, 0]);\n\n            default:\n              throw new Error('not supported color');\n          }\n        }\n      } else if (true === Array.isArray(prm)) {\n        return new mofron.class.Color(prm);\n      } else if (true === comutl.isinc(prm, 'Color')) {\n        return prm;\n      } else {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getsize: prm => {\n    try {\n      let siz = null;\n      /* parameter check */\n\n      if ('string' !== typeof prm) {\n        if (null === prm || undefined === prm) {\n          return null;\n        } else if (true === comutl.isinc(prm, \"Size\")) {\n          return prm;\n        } else {\n          throw new Error('invalid parameter');\n        }\n      }\n      /* get size type */\n\n\n      let stype = ['px', '%', 'rem', 'em', 'vw', 'vh'];\n      let ptype = null;\n\n      for (let sidx in stype) {\n        if (2 !== prm.split(stype[sidx]).length) {\n          continue;\n        }\n\n        ptype = stype[sidx];\n        break;\n      }\n\n      if (null === ptype) {\n        throw new Error('not supported size type');\n      }\n      /* get value */\n\n\n      let sval = null;\n      sp_prm = prm.split(ptype);\n\n      if (2 === sp_prm[0].split('.').length) {\n        sval = parseFloat(sp_prm[0]);\n      } else {\n        sval = parseInt(sp_prm[0]);\n      }\n\n      if ('px' === ptype) {\n        return new mofron.class.Pixel(sval);\n      } else if ('rem' === ptype) {\n        return new mofron.class.Rem(sval);\n      } else {\n        return new mofron.class.Size(sval, ptype);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizetype: prm => {\n    try {\n      let size = comutl.getsize(prm);\n      return null === size ? null : size.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizesum: (p1, p2) => {\n    try {\n      let prm1 = 'string' === typeof p1 ? comutl.getsize(p1) : p1;\n      let prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (null == prm1 && true === comutl.isinc(prm2, ['Base', 'Size'])) {\n        return prm2.toString();\n      } else if (null == prm2 && true === comutl.isinc(prm1, ['Base', 'Size'])) {\n        return prm1.toString();\n      } else if (null === prm1 && null === prm2) {\n        return null;\n      }\n\n      if (true !== comutl.isinc(prm1, ['Base', 'Size']) || true !== comutl.isinc(prm2, ['Base', 'Size'])) {\n        throw new Error('invalid parameter');\n      }\n\n      if (prm1.type() !== prm2.type()) {\n        if (undefined === prm1.toPixel() || undefined === prm2.toPixel()) {\n          throw new Error('not supported type');\n        }\n\n        return new mofron.class.Pixel(prm1.toPixel() + prm2.toPixel()).toString();\n      } else {\n        let val_1 = comutl.roundup(prm1.value());\n        let val_2 = comutl.roundup(prm2.value());\n        return comutl.roundup(val_1 + val_2) + prm1.type();\n      }\n    } catch (e) {\n      throw e;\n    }\n  },\n  sizediff: (p1, p2) => {\n    try {\n      let prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (true !== comutl.isinc(prm2, \"Size\")) {\n        throw new Error('not supported type');\n      }\n\n      let prm2_buf = comutl.getsize(prm2.toString());\n      prm2_buf.value(prm2_buf.value() * -1);\n      return comutl.sizesum(p1, prm2_buf);\n    } catch (e) {\n      throw e;\n    }\n  },\n  roundup: prm => {\n    try {\n      let flo = comutl.flo2int(prm);\n\n      if (1000 >= flo[1]) {\n        return prm;\n      }\n\n      return Math.floor(flo[0] / flo[1] * 1000) / 1000;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  flo2int: prm => {\n    try {\n      if ('number' !== typeof prm) {\n        throw new Error('invalid parameter');\n      }\n\n      let chk = null;\n      let pos = 0;\n      let wei = 1;\n      chk = prm + '';\n      pos = chk.indexOf('.');\n\n      if (-1 === pos) {\n        return [prm, 1];\n      }\n\n      for (pos = chk.length - 1 - pos; 0 < pos; pos--) {\n        wei = wei * 10;\n      }\n\n      return [prm * wei, wei];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  chkacc: opt => {\n    try {\n      for (let oidx in opt) {\n        if (\"device\" !== oidx && \"os\" !== oidx && \"browser\" !== oidx && \"orientation\" !== oidx) {\n          console.warn(\"unknown index:\" + oidx);\n          return false;\n        }\n\n        if (\"device\" === oidx) {\n          if (true === Array.isArray(opt[oidx])) {\n            let dev_chk = false;\n\n            for (let didx in opt[oidx]) {\n              if (opt[oidx][didx] === comutl.accdev()) {\n                dev_chk = true;\n              }\n            }\n\n            if (false === dev_chk) {\n              return false;\n            }\n          } else {\n            if (opt[oidx] !== comutl.accdev()) {\n              return false;\n            }\n          }\n        } else if (\"os\" === oidx) {\n          if (opt[oidx] !== comutl.accos()) {\n            return false;\n          }\n        } else if (\"browser\" === oidx) {\n          if (opt[oidx] !== comutl.accbrs()) {\n            return false;\n          }\n        } else if (\"orientation\" === oidx) {\n          let ochk = \"portrait\" === opt.orientation ? true : false;\n\n          if (ochk !== mofron.window.isPortrait()) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accdev: () => {\n    try {\n      let ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('Android') > 0 && ua.indexOf('Mobile') > 0) {\n        return 'mobile';\n      } else if (ua.indexOf('iPad') > 0 || ua.indexOf('Android') > 0) {\n        return 'tablet';\n      } else {\n        return 'default';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accos: () => {\n    try {\n      let ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('iPad') > 0) {\n        return 'ios';\n      } else if (ua.indexOf('Android') > 0) {\n        return 'android';\n      } else if (ua.indexOf('Windows') > 0) {\n        return 'windows';\n      } else if (ua.indexOf('Mac OS') > 0) {\n        return 'mac';\n      } else if (ua.indexOf('Linux') > 0) {\n        return 'linux';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accbrs: () => {\n    try {\n      let ua = window.navigator.userAgent.toLowerCase();\n\n      if (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1) {\n        return 'ie';\n      } else if (ua.indexOf('edge') != -1) {\n        return 'edge';\n      } else if (ua.indexOf('chrome') != -1) {\n        return 'chrome';\n      } else if (ua.indexOf('safari') != -1) {\n        return 'safari';\n      } else if (ua.indexOf('firefox') != -1) {\n        return 'firefox';\n      } else if (ua.indexOf('opera') != -1) {\n        return 'opera';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addhead: (tag, atr, txt) => {\n    try {\n      let conts = \"<\" + tag + \" \";\n      /* set attributes */\n\n      for (let aidx in atr) {\n        conts += aidx + '=' + atr[aidx] + ' ';\n      }\n\n      conts = conts.substring(0, conts.length - 1) + \">\";\n\n      if ('link' !== tag && 'meta' !== tag && 'base' !== tag) {\n        /* set contents */\n        conts += txt + \"</\" + tag + \">\";\n      }\n\n      if (undefined !== mofron.ssr) {\n        mofron.ssr.head(conts);\n      } else {\n        document.head.insertAdjacentHTML('beforeend', conts);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addstyle: (id, prm, append) => {\n    try {\n      let style = document.getElementById(id);\n\n      if (null === style) {\n        comutl.addhead(\"style\", {\n          id: id\n        }, prm);\n      } else if (false !== append) {\n        style.innerText += prm;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  obj2style: (sel, cnt) => {\n    try {\n      let ret = sel + \" {\";\n\n      for (let cidx in cnt) {\n        ret += cidx + \":\" + cnt[cidx] + \";\";\n      }\n\n      return ret + \"}\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst comutl = mofron.util.common;\nmodule.exports = mofron.util.common;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/common.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/component.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/util/component.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @file component.js\n * @brief util functions for component\n * @license MIT\n */\nconst comutl = mofron.util.common;\nmofron.util.component = {\n  chdloop: (cmp, key, prm) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let chd = cmp.getTree().getChild();\n      let argc = false === Array.isArray(prm) ? 0 : prm.length;\n\n      for (let cidx in chd) {\n        if (0 === argc) {\n          chd[cidx][key]();\n        } else if (1 === argc) {\n          chd[cidx][key](p1);\n        } else if (2 === argc) {\n          chd[cidx][key](p1, p2);\n        } else if (3 === argc) {\n          chd[cidx][key](p1, p2, p3);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  ischild: (pnt, cmp) => {\n    try {\n      let ret = false;\n      let pchd = pnt.getTree().child();\n\n      for (let cidx in pchd) {\n        if (true === comutl.ischild(chd[cidx], cmp)) {\n          return true;\n        } else if (chd[cidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isinncmp: cmp => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let chd_cmp = cmp.childDom().component();\n\n      if (null === chd_cmp || null === chd_cmp.getTree().parent()) {\n        return false;\n      }\n\n      let pnt_buf = chd_cmp.getTree().parent();\n\n      while (null !== pnt_buf) {\n        if (cmp.id() === pnt_buf.id()) {\n          /* target is inner component */\n          return true;\n        }\n\n        pnt_buf = pnt_buf.getTree().parent();\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  modconf: (cmp, idx, po, opt) => {\n    try {\n      if (true === comutl.isinc(po, \"ModConf\") && true === po.innerTgt() && true === cmputl.isinncmp(cmp)) {\n        return cmputl.modconf(cmp.childDom().component(), idx, po, opt);\n      }\n\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid component object\");\n      } else if (\"layout\" !== idx && \"effect\" !== idx && \"event\" !== idx) {\n        throw new Error(\"invalid index:\" + idx);\n      }\n\n      if (true === Array.isArray(po)) {\n        for (let pidx in po) {\n          cmputl.modconf(cmp, idx, po[pidx], opt);\n        }\n\n        return;\n      }\n\n      if (false === comutl.isinc(po, \"ModConf\")) {\n        /* getter */\n        let get_cmp = true === cmputl.isinncmp(cmp) ? cmp.childDom().component() : cmp;\n        let mc_lst = get_cmp.confmng().get(idx);\n\n        if ('object' !== typeof po) {\n          return mc_lst;\n        }\n\n        let ret = [];\n        let hit = null;\n\n        for (let mc_idx in mc_lst) {\n          hit = true;\n\n          for (let pidx in po) {\n            if (mc_lst[mc_idx][pidx]() !== po[pidx]) {\n              hit = false;\n              break;\n            }\n          }\n\n          if (true === hit) {\n            ret.push(mc_lst[mc_idx]);\n          }\n        }\n\n        if (0 === ret.length) {\n          return null;\n        } else {\n          return 1 === ret.length ? ret[0] : ret;\n        }\n      }\n      /* setter */\n\n\n      po.component(cmp);\n      cmp.confmng(idx, po, opt);\n\n      if (true === cmp.isExists() && \"effect\" !== idx) {\n        po.execute();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initmconf: (cmp, idx) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let chd = cmp.getTree().getChild();\n\n      for (let cidx in chd) {\n        cmputl.initmconf(chd[cidx], idx);\n      }\n      /* init module config */\n\n\n      if (\"effect\" === idx || \"zsp_effect\" === idx) {\n        /* init effect */\n        let efflst = cmputl.modconf(cmp, \"effect\");\n        let eid = \"none\" !== cmp.style(\"display\") ? 0 : 1;\n        let oid = 0;\n        let exelst = [];\n\n        while (true) {\n          efflst = mofron.util.effect.getlist(efflst, eid, oid);\n\n          if (0 === efflst.length) {\n            break;\n          }\n\n          oid++;\n\n          for (let eidx in efflst) {\n            if (idx === \"effect\" && 0 !== efflst[eidx].speed() || idx === \"zsp_effect\" && 0 === efflst[eidx].speed()) {\n              exelst.push(efflst[eidx]);\n            }\n          }\n        }\n\n        mofron.util.effect.exec(exelst, eid);\n      } else {\n        let cnf = cmputl.modconf(cmp, idx);\n\n        for (let cfidx in cnf) {\n          cnf[cfidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  theme: (cmp, thm) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      /*\n       * create the theme for execution with theme of component\n       * added to theme of parameter.\n       */\n\n\n      let exe_thm = {};\n\n      for (let thm_idx in thm) {\n        exe_thm[thm_idx] = thm[thm_idx];\n      }\n\n      let cmp_thm = cmp.theme();\n\n      for (let cmp_idx in cmp_thm) {\n        exe_thm[cmp_idx] = cmp_thm[cmp_idx];\n      }\n      /* check ignore */\n\n\n      let is_ign = false;\n      let exe_thm2 = {};\n\n      for (let e_idx in exe_thm) {\n        is_ign = false;\n\n        if (undefined !== exe_thm[e_idx].ignore) {\n          if (true === Array.isArray(exe_thm[e_idx].ignore)) {\n            for (let e_idx2 in exe_thm[e_idx].ignore) {\n              if (cmp.name() === exe_thm[e_idx].ignore[e_idx2]) {\n                is_ign = true;\n              }\n            }\n          } else if (cmp.name() === exe_thm[e_idx].ignore) {\n            is_ign = true;\n          }\n        }\n\n        if (false === is_ign) {\n          exe_thm2[e_idx] = exe_thm[e_idx];\n        }\n      }\n\n      let chd = cmp.getTree().getChild();\n      let inn_cmp = cmp.confmng(\"innerComp\");\n      /* theme core process */\n\n      for (let thm_tgt in exe_thm2) {\n        if (true === comutl.isinc(cmp, thm_tgt)) {\n          if (undefined !== exe_thm2[thm_tgt].replace) {\n            if (true === comutl.isobj(cmp, thm_tgt)) {\n              /* replace component */\n              let rep_cmp = new exe_thm2[thm_tgt].replace();\n\n              if (undefined !== exe_thm2[thm_tgt].config) {\n                rep_cmp.config(exe_thm2[thm_tgt].config);\n              }\n\n              rep_cmp.config(cmp.config());\n              cmp.parent().getTree().replace(cmp, rep_cmp);\n              /* update child list for execution theme */\n\n              chd = rep_cmp.getTree().getChild(); //let rep_inn = rep_cmp.confmng(\"innerComp\");\n\n              for (let inn_idx2 in inn_cmp) {\n                rep_cmp[inn_idx2]().config(inn_cmp[inn_idx2].config());\n              }\n            }\n          } else if (undefined !== exe_thm2[thm_tgt].config) {\n            /* config theme */\n            cmp.config(exe_thm2[thm_tgt].config);\n          }\n        }\n\n        for (let inn_idx in inn_cmp) {\n          if (true === comutl.isobj(inn_cmp[inn_idx], thm_tgt) && undefined !== exe_thm2[thm_tgt].replace) {\n            let rep_inn = new exe_thm2[thm_tgt].replace();\n\n            if (undefined !== exe_thm2[thm_tgt].config) {\n              rep_inn.config(exe_thm2[thm_tgt].config);\n            }\n\n            rep_inn.config(inn_cmp[inn_idx].config());\n            inn_cmp[inn_idx].parent().getTree().replace(inn_cmp[inn_idx], rep_inn);\n            inn_cmp[inn_idx] = rep_inn;\n            break;\n          }\n        }\n      }\n      /* execute child theme */\n\n\n      for (let cidx in chd) {\n        let buf_thm = {};\n\n        for (let eth_idx in exe_thm2) {\n          buf_thm[eth_idx] = exe_thm2[eth_idx];\n        }\n\n        mofron.util.component.theme(chd[cidx], buf_thm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  size: (cmp, key, val, opt) => {\n    try {\n      /* setter */\n      if (false === comutl.iscmp(cmp) || \"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      let style_val = {};\n\n      if (null === comutl.getsize(val)) {\n        style_val[key] = null;\n      } else {\n        style_val[key] = comutl.getsize(val).toString();\n      }\n\n      cmp.config({\n        style: new mofron.class.ConfArg(style_val, opt)\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  color: (cmp, key, val, opt) => {\n    try {\n      if (false === comutl.iscmp(cmp) || \"string\" !== typeof key) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      let style_val = {};\n      style_val[key] = null === val ? null : comutl.getcolor(val).toString();\n\n      if (undefined === opt) {\n        opt = {\n          private: true\n        };\n      } else {\n        opt.private = true;\n      }\n\n      cmp.style(style_val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  display: (cmp, flg) => {\n    try {\n      /* check parameter */\n      if (false === comutl.iscmp(cmp) || 'boolean' !== typeof flg) {\n        throw new Error('invalid parameter');\n      }\n\n      let buf = null;\n      let rdom = cmp.rootDom();\n\n      for (let ridx in rdom) {\n        if (true === flg) {\n          /* diplayed target dom, set display value from buffer */\n          if ('none' === rdom[ridx].style(\"display\") && true === rdom[ridx].isPushed()) {\n            buf = cmputl.dispbuff(rdom[ridx]);\n            rdom[ridx].style({\n              \"display\": undefined === buf ? null : buf\n            });\n            cmputl.dispbuff(rdom[ridx], null);\n          }\n        } else {\n          /* hidden target dom, buffering display value */\n          buf = rdom[ridx].style(\"display\");\n\n          if ('none' !== buf && null !== buf) {\n            cmputl.dispbuff(rdom[ridx], buf);\n          }\n\n          rdom[ridx].style({\n            \"display\": \"none\"\n          });\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  dispbuff: (dom, val) => {\n    try {\n      if (false === comutl.isinc(dom, \"Dom\")) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let dkey = dom.id() + \"_display\";\n\n      if (undefined === val) {\n        /* getter */\n        return dom.data(dkey);\n      }\n      /* setter */\n\n\n      dom.data(dkey, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  visible: (cmp, vflg, ef, ep) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      if (undefined === vflg) {\n        /* getter */\n        if (false === cmp.isExists()) {\n          /* it does not rendered yet */\n          return false;\n        }\n\n        let doms = cmp.rootDom();\n\n        for (let didx in doms) {\n          if ('none' !== doms[didx].style('display')) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /* setter */\n\n\n      if ('boolean' !== typeof vflg) {\n        throw new Error('invalid parameter');\n      }\n\n      if (false === cmp.isExists()) {\n        /* render component */\n        cmputl.display(cmp, vflg);\n\n        if (true === vflg) {\n          cmputl.render(cmp, ef, ep);\n        }\n\n        return;\n      } else if (true === vflg) {\n        cmputl.display(cmp, vflg);\n      }\n\n      let scb = () => {\n        try {\n          if (false === vflg) {\n            cmputl.display(cmp, false);\n          }\n\n          if (\"function\" === typeof ef) {\n            ef(cmp, cmp.visible(), ep);\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      if (false === cmp.execEffect(true === vflg ? 0 : 1, scb)) {\n        /* it doesn't execute effect */\n        scb();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  render: (cmp, cbf, cbp) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n      /* execute theme */\n\n\n      cmputl.theme(cmp, {});\n      /* execute layout modules */\n\n      cmputl.initmconf(cmp, \"layout\");\n      /* before push event */\n\n      cmp.beforeRender();\n      /* execute effect module that is 0 speed */\n\n      cmputl.initmconf(cmp, \"zsp_effect\");\n      /* render */\n\n      let rdom = cmp.rootDom();\n\n      for (let ridx in rdom) {\n        if (null === rdom[ridx].parent()) {\n          rdom[ridx].push({\n            target: document.body\n          });\n        } else {\n          let cmp_idx = cmp.parent().getTree().getIndex(cmp);\n          let pc_len = cmp.parent().child().length;\n\n          if (cmp_idx === pc_len - 1) {\n            /* insert to last of parent */\n            rdom[ridx].push({\n              target: rdom[ridx].parent().getRawDom()\n            });\n          } else {\n            /* insert to target index of parent */\n            rdom[ridx].push({\n              target: cmp.parent().child()[cmp_idx + 1].rootDom()[0].getRawDom(),\n              position: 'beforebegin'\n            });\n          }\n        }\n      }\n      /* after push event */\n\n\n      cmp.afterRender();\n\n      if (\"function\" === typeof cbf) {\n        cbf(cmp, cmp.visible(), cbp);\n      }\n      /* execute effect modules */\n\n\n      cmputl.initmconf(cmp, \"effect\");\n      /* execute event modules */\n\n      cmputl.initmconf(cmp, \"event\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  rstyle: (cmp, sty, opt) => {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      let root = cmp.rootDom();\n\n      for (let ridx in root) {\n        root[ridx].style(sty, opt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst cmputl = mofron.util.component;\nmodule.exports = mofron.util.component;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/component.js?");

/***/ }),

/***/ "./node_modules/mofron/src/util/effect.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/effect.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * @file effect.js\n */\nconst cmputl = mofron.util.component;\nmofron.util.effect = {\n  exec: (eff, eid, evf, oid) => {\n    try {\n      let _oid = undefined === oid ? 0 : oid;\n\n      let elst = effutl.getlist(eff, eid, _oid);\n\n      if (0 === elst.length) {\n        return false;\n      }\n      /* execute before event */\n\n\n      for (let eidx in elst) {\n        let b_evt = elst[eidx].beforeEvent();\n\n        for (let bidx in b_evt) {\n          b_evt[bidx][0](elst[eidx], elst[eidx].component(), b_evt[bidx][1]);\n        }\n      }\n      /* set transition */\n\n\n      effutl.transition(elst);\n\n      let next_order = () => {\n        let fin_cnt = 0;\n        return (p1, p2, p3) => {\n          try {\n            let eff_cmp = elst[fin_cnt].component();\n            fin_cnt++;\n\n            if (p3 <= fin_cnt) {\n              if (false === effutl.exec(eff, eid, evf, oid + 1)) {\n                /* release transition */\n                cmputl.rstyle(eff_cmp, {\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                eff_cmp.styleDom().style({\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                /* execute callback function */\n\n                if (undefined !== evf && \"function\" === typeof evf[0]) {\n                  evf[0](p2, eid, evf[1]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n      };\n\n      let next = next_order(eff, eid, evf, oid);\n\n      for (let eidx2 in elst) {\n        elst[eidx2].otCallback(next, elst.length);\n\n        if (0 === elst[eidx2].speed()) {\n          elst[eidx2].execute();\n        } else {\n          setTimeout(tm => {\n            try {\n              tm.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          }, 50, elst[eidx2]);\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n\n  /**\n   * get valid list from effect lists\n   */\n  getlist: (eff, eid, oid) => {\n    try {\n      let elst = [];\n\n      for (let eidx in eff) {\n        if (true === eff[eidx].isSkipped(eid, oid)) {\n          continue;\n        }\n\n        elst.push(eff[eidx]);\n      }\n\n      return elst;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initlist: cmp => {\n    try {\n      let ret = [];\n      let chd = cmp.child();\n\n      for (let cidx in chd) {\n        let chd_ret = effutl.initlist(chd[cidx]);\n\n        if (null !== chd_ret) {\n          for (let cidx in chd_ret) {\n            ret.push(chd_ret[cidx]);\n          }\n        }\n      }\n\n      let eff = cmputl.modconf(cmp, \"effect\");\n      let oid = 0;\n      let buf = null;\n\n      while (true) {\n        buf = effutl.getlist(eff, true === cmp.visible() ? 0 : 1, oid);\n\n        if (0 === buf.length) {\n          break;\n        }\n\n        for (let bidx in buf) {\n          ret.push(buf[bidx]);\n        }\n\n        oid++;\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  transition: eff => {\n    try {\n      let rdom = eff[0].component().rootDom();\n      let cmp_trans = {}; //effutl.gettrans(rdom.style('tarnsition'));\n\n      /* get the effect transition that will be executed */\n\n      let eff_trans = {};\n\n      for (let eidx in eff) {\n        if (0 === eff[eidx].speed()) {\n          continue;\n        }\n\n        let tbuf = eff[eidx].transition();\n\n        for (let bidx in tbuf) {\n          eff_trans[tbuf[bidx]] = eff[eidx].speed() + 'ms ';\n\n          if (null === eff[eidx].cubicBezier()) {\n            eff_trans[tbuf[bidx]] += eff[eidx].timing();\n          } else {\n            let cubic = eff[eidx].cubicBezier();\n            eff_trans[tbuf[bidx]] += 'cubic-bezier(' + cubic[0] + ',' + cubic[1] + ',' + cubic[2] + ',' + cubic[3] + ')';\n          }\n\n          eff_trans[tbuf[bidx]] += ' ' + eff[eidx].delay() + 'ms';\n        }\n      }\n\n      if (0 === Object.keys(eff_trans).length) {\n        return;\n      }\n      /* set transition list to buff */\n\n\n      for (let tidx in eff_trans) {\n        cmp_trans[tidx] = eff_trans[tidx];\n      }\n\n      let setval = {\n        'transition': \"\"\n      };\n\n      for (let tidx2 in cmp_trans) {\n        setval.transition += tidx2 + \" \" + cmp_trans[tidx2] + \",\";\n      }\n\n      if (0 < setval.transition.length) {\n        setval.transition = setval.transition.substring(0, setval.transition.length - 1);\n      }\n\n      cmputl.rstyle(eff[0].component(), setval, {\n        bpref: true\n      });\n      eff[0].component().styleDom().style(setval, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getfirst: (eff, eid, ord) => {\n    try {\n      for (let eidx in eff) {\n        if (false === eff[eidx].isSkipped(eid, ord)) {\n          return parseInt(eidx);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getlast: (eff, eid, ord) => {\n    try {\n      let tgt_lst = [];\n\n      for (let eidx in eff) {\n        if (eid !== eff[eidx].eid()) {\n          continue;\n        } else if ('number' === typeof ord && ord !== eff[eidx].order()) {\n          continue;\n        }\n\n        tgt_lst.push(eff[eidx]);\n      }\n\n      if (0 === tgt_lst.length) {\n        return null;\n      }\n\n      let last = tgt_lst[tgt_lst.length - 1];\n\n      for (let eidx2 in eff) {\n        if (eff[eidx2].id() === last.id()) {\n          return parseInt(eidx2);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  setconf: (cmp, einf, cnf) => {\n    try {\n      let eff = cmp.effect(einf);\n\n      if (null === eff) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      eff = true !== Array.isArray(eff) ? [eff] : eff;\n\n      for (let eidx in eff) {\n        eff[eidx].config(cnf);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nconst effutl = mofron.util.effect;\nmodule.exports = mofron.util.effect;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/effect.js?");

/***/ }),

/***/ "./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!../../../babel-loader/lib/index.js??ruleSet[1].rules[0].use!./namesp.js */ \"./node_modules/babel-loader/lib/index.js??ruleSet[1].rules[0].use!./node_modules/mofron/src/core/namesp.js\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../../../expose-loader/dist/runtime/getGlobalThis.js */ \"./node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"mofron\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"mofron\"] = ___EXPOSE_LOADER_IMPORT___;\nelse throw new Error('[exposes-loader] The \"mofron\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option')\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp-exposed.js?./node_modules/expose-loader/dist/cjs.js?exposes=mofron");

/***/ }),

/***/ "./node_modules/mofron/index.js":
/*!**************************************!*\
  !*** ./node_modules/mofron/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! expose-loader?exposes=mofron!./src/core/namesp.js */ \"./node_modules/expose-loader/dist/cjs.js?exposes=mofron!./node_modules/mofron/src/core/namesp-exposed.js\");\n\n/* util functions */\n__webpack_require__(/*! ./src/util/common.js */ \"./node_modules/mofron/src/util/common.js\");\n__webpack_require__(/*! ./src/util/component.js */ \"./node_modules/mofron/src/util/component.js\");\n__webpack_require__(/*! ./src/util/effect.js */ \"./node_modules/mofron/src/util/effect.js\");\n\nmofron.class.ConfArg  = __webpack_require__(/*! ./src/type/ConfArg.js */ \"./node_modules/mofron/src/type/ConfArg.js\");\nmofron.class.PullConf = __webpack_require__(/*! ./src/type/PullConf.js */ \"./node_modules/mofron/src/type/PullConf.js\");\n\nmofron.class.Dom       = __webpack_require__(/*! ./src/core/dom/Dom.js */ \"./node_modules/mofron/src/core/dom/Dom.js\");\nmofron.class.Component = __webpack_require__(/*! ./src/tag/Component.js */ \"./node_modules/mofron/src/tag/Component.js\");\nmofron.class.Layout    = __webpack_require__(/*! ./src/tag/Layout.js */ \"./node_modules/mofron/src/tag/Layout.js\");\nmofron.class.Effect    = __webpack_require__(/*! ./src/tag/Effect.js */ \"./node_modules/mofron/src/tag/Effect.js\");\nmofron.class.Event     = __webpack_require__(/*! ./src/tag/Event.js */ \"./node_modules/mofron/src/tag/Event.js\");\nmofron.class.Color     = __webpack_require__(/*! ./src/type/Color.js */ \"./node_modules/mofron/src/type/Color.js\");\nmofron.class.Size      = __webpack_require__(/*! ./src/type/size/Size.js */ \"./node_modules/mofron/src/type/size/Size.js\");\nmofron.class.Pixel     = __webpack_require__(/*! ./src/type/size/Pixel.js */ \"./node_modules/mofron/src/type/size/Pixel.js\");\nmofron.class.Rem       = __webpack_require__(/*! ./src/type/size/Rem.js */ \"./node_modules/mofron/src/type/size/Rem.js\");\n\nlet Window = __webpack_require__(/*! ./src/core/Window.js */ \"./node_modules/mofron/src/core/Window.js\");\nmofron.window = new Window();\nlet Document = __webpack_require__(/*! ./src/core/Document.js */ \"./node_modules/mofron/src/core/Document.js\");\nmofron.document = new Document();\n\nmodule.exports = mofron;\n\n\n//# sourceURL=webpack:///./node_modules/mofron/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/index.js");
/******/ 	
/******/ })()
;